function ChallengeCard({ challenge }) {
  return (
    <View style={styles.challengeCard}>
      <View style={styles.challengeHeader}>
        <Text style={styles.challengeIcon}>{challenge.icon}</Text>
        <View style={styles.challengeInfo}>
          <Text style={styles.challengeName}>{challenge.name}</Text>
          <Text style={styles.challengeDescription}>
            {challenge.description}
          </Text>
        </View>
        {challenge.completed && (
          <Text style={styles.challengeCompleted}>âœ“</Text>
        )}
      </View>
      
      {!challenge.completed && (
        <>
          <ProgressBar
            progress={challenge.progress / challenge.goal}
            color="#3498DB"
          />
          <Text style={styles.challengeProgress}>
            {challenge.progress} / {challenge.goal}
          </Text>
        </>
      )}
      
      <Text style={styles.challengeReward}>
        Reward: {challenge.reward}
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  card: {
    margin: 12,
    elevation: 3,
  },
  badgesCard: {
    backgroundColor: '#FFF9C4',
  },
  hero: {
    padding: 24,
    alignItems: 'center',
    backgroundColor: '#FFF',
    borderBottomLeftRadius: 24,
    borderBottomRightRadius: 24,
    elevation: 2,
  },
  celebration: {
    width: 200,
    height: 150,
  },
  heroGreeting: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  heroSubtext: {
    fontSize: 16,
    color: '#666',
    marginTop: 8,
  },
  changeIndicator: {
    marginTop: 16,
    alignItems: 'center',
  },
  changeUp: {
    fontSize: 20,
    color: '#2ECC71',
    fontWeight: 'bold',
  },
  changeText: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  badgesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-around',
  },
  badgeCard: {
    width: '45%',
    padding: 16,
    backgroundColor: '#FFF',
    borderRadius: 12,
    alignItems: 'center',
    marginBottom: 12,
    elevation: 2,
  },
  badgeEmoji: {
    fontSize: 48,
    marginBottom: 8,
  },
  badgeName: {
    fontSize: 14,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  badgeDescription: {
    fontSize: 11,
    color: '#666',
    textAlign: 'center',
    marginTop: 4,
  },
  streakContainer: {
    alignItems: 'center',
    marginBottom: 16,
  },
  streakCurrent: {
    alignItems: 'center',
  },
  streakNumber: {
    fontSize: 64,
    fontWeight: 'bold',
    color: '#F39C12',
  },
  streakLabel: {
    fontSize: 16,
    color: '#666',
  },
  streakActive: {
    fontSize: 18,
    color: '#E74C3C',
    fontWeight: 'bold',
    marginTop: 8,
  },
  streakMilestone: {
    marginTop: 16,
  },
  streakMilestoneText: {
    fontSize: 13,
    color: '#666',
    marginTop: 8,
    textAlign: 'center',
  },
  streakRecord: {
    fontSize: 12,
    color: '#999',
    textAlign: 'center',
    marginTop: 12,
  },
  storyContainer: {
    alignItems: 'center',
  },
  storyImage: {
    width: '100%',
    height: 200,
    borderRadius: 12,
    marginBottom: 16,
  },
  storyText: {
    fontSize: 15,
    lineHeight: 22,
    color: '#333',
    textAlign: 'center',
    marginBottom: 12,
  },
  storyOrg: {
    fontSize: 13,
    fontStyle: 'italic',
    color: '#666',
  },
  storyDots: {
    flexDirection: 'row',
    marginTop: 16,
  },
  dot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: '#CCC',
    marginHorizontal: 4,
  },
  dotActive: {
    backgroundColor: '#2ECC71',
    width: 24,
  },
  comparisonGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  challengeCard: {
    padding: 16,
    backgroundColor: '#F9F9F9',
    borderRadius: 12,
    marginBottom: 12,
  },
  challengeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  challengeIcon: {
    fontSize: 32,
    marginRight: 12,
  },
  challengeInfo: {
    flex: 1,
  },
  challengeName: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  challengeDescription: {
    fontSize: 13,
    color: '#666',
    marginTop: 2,
  },
  challengeCompleted: {
    fontSize: 24,
    color: '#2ECC71',
  },
  challengeProgress: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  challengeReward: {
    fontSize: 12,
    color: '#F39C12',
    marginTop: 8,
    fontWeight: '600',
  },
  shareButton: {
    margin: 16,
    paddingVertical: 8,
  },
});
```

---

## 6. Backend Implementation

### 6.1 Monthly Report Generation

```javascript
// services/report_generator.js
const moment = require('moment');

class ReportGenerator {
  async generateMonthlyReport(userId, month = null) {
    const targetMonth = month || moment().subtract(1, 'month');
    
    // Gather all data
    const data = await Promise.all([
      this.getDonationSummary(userId, targetMonth),
      this.getStreak(userId),
      this.getMilestones(userId),
      this.getNewBadges(userId, targetMonth),
      this.getComparison(userId, targetMonth),
      this.getImpactStories(userId, targetMonth),
      this.getChallenges(userId, targetMonth),
      this.getSuggestions(userId)
    ]);
    
    const [
      summary,
      streak,
      milestones,
      newBadges,
      comparison,
      stories,
      challenges,
      suggestions
    ] = data;
    
    // Generate report object
    const report = {
      user_id: userId,
      month: targetMonth.format('YYYY-MM'),
      generated_at: new Date(),
      
      // Hero section
      monthly_total: summary.total,
      donation_count: summary.count,
      month_over_month_change: comparison.mom_change,
      
      // Badges
      new_badges: newBadges,
      
      // Streak
      streak: streak,
      
      // Breakdown
      donations_by_country: summary.by_country,
      donations_by_cause: summary.by_cause,
      organizations_supported: summary.organizations,
      
      // Timeline
      timeline: await this.getTimeline(userId, 6), // 6 months
      
      // Progress
      milestones: milestones,
      
      // Stories
      impact_stories: stories,
      
      // Comparison
      comparison: comparison,
      
      // Challenges
      challenges: challenges,
      
      // Next steps
      suggestions: suggestions,
      
      // Shareable
      shareable_url: await this.generateShareableUrl(userId, targetMonth)
    };
    
    // Store report
    await this.storeReport(report);
    
    return report;
  }
  
  async getDonationSummary(userId, month) {
    const startDate = month.clone().startOf('month');
    const endDate = month.clone().endOf('month');
    
    const result = await db.query(`
      SELECT 
        SUM(amount) as total,
        COUNT(*) as count,
        ARRAY_AGG(DISTINCT organization_id) as org_ids
      FROM donations
      WHERE user_id = $1
      AND created_at BETWEEN $2 AND $3
      AND status = 'succeeded'
    `, [userId, startDate.toDate(), endDate.toDate()]);
    
    const summary = result.rows[0];
    
    // Get breakdown by country
    const byCountry = await db.query(`
      SELECT 
        c.country_name,
        c.country_code,
        SUM(d.amount) as amount,
        COUNT(*) as donation_count
      FROM donations d
      JOIN conflicts c ON d.conflict_id = c.id
      WHERE d.user_id = $1
      AND d.created_at BETWEEN $2 AND $3
      AND d.status = 'succeeded'
      GROUP BY c.country_name, c.country_code
      ORDER BY amount DESC
    `, [userId, startDate.toDate(), endDate.toDate()]);
    
    // Get breakdown by cause
    const byCause = await db.query(`
      SELECT 
        unnest(c.tags) as cause,
        SUM(d.amount) as amount,
        COUNT(*) as donation_count
      FROM donations d
      JOIN conflicts c ON d.conflict_id = c.id
      WHERE d.user_id = $1
      AND d.created_at BETWEEN $2 AND $3
      AND d.status = 'succeeded'
      GROUP BY cause
      ORDER BY amount DESC
    `, [userId, startDate.toDate(), endDate.toDate()]);
    
    return {
      total: parseFloat(summary.total || 0),
      count: parseInt(summary.count),
      by_country: byCountry.rows,
      by_cause: byCause.rows,
      organizations: summary.org_ids || []
    };
  }
  
  async getStreak(userId) {
    const streaks = await db.query(`
      WITH monthly_donations AS (
        SELECT DISTINCT 
          DATE_TRUNC('month', created_at) as month
        FROM donations
        WHERE user_id = $1 AND status = 'succeeded'
        ORDER BY month DESC
      ),
      streak_calc AS (
        SELECT 
          month,
          month - (ROW_NUMBER() OVER (ORDER BY month DESC) || ' months')::INTERVAL as grp
        FROM monthly_donations
      )
      SELECT 
        COUNT(*) as streak_length,
        MIN(month) as streak_start,
        MAX(month) as streak_end
      FROM streak_calc
      GROUP BY grp
      ORDER BY MAX(month) DESC
      LIMIT 1
    `, [userId]);
    
    const currentStreak = streaks.rows[0];
    const streakLength = currentStreak ? parseInt(currentStreak.streak_length) : 0;
    
    // Check if streak is active (includes current or last month)
    const lastMonth = moment().subtract(1, 'month').startOf('month');
    const streakEnd = currentStreak ? moment(currentStreak.streak_end) : null;
    const isActive = streakEnd && streakEnd.isSameOrAfter(lastMonth);
    
    // Get longest streak ever
    const longest = await db.query(`
      SELECT MAX(streak_length) as longest
      FROM (
        SELECT COUNT(*) as streak_length
        FROM (
          SELECT 
            month,
            month - (ROW_NUMBER() OVER (ORDER BY month DESC) || ' months')::INTERVAL as grp
          FROM (
            SELECT DISTINCT DATE_TRUNC('month', created_at) as month
            FROM donations
            WHERE user_id = $1 AND status = 'succeeded'
          ) monthly_donations
        ) streak_calc
        GROUP BY grp
      ) all_streaks
    `, [userId]);
    
    const longestStreak = parseInt(longest.rows[0]?.longest || 0);
    
    // Determine next milestone
    const MILESTONES = [2, 3, 6, 12, 24, 36];
    const nextMilestone = MILESTONES.find(m => m > streakLength) || streakLength + 12;
    
    return {
      current: streakLength,
      longest: longestStreak,
      isActive: isActive,
      emoji: this.getStreakEmoji(streakLength),
      next_milestone: nextMilestone,
      next_reward: this.getStreakReward(nextMilestone)
    };
  }
  
  getStreakEmoji(months) {
    if (months >= 24) return "ðŸ’«";
    if (months >= 12) return "ðŸŒŸ";
    if (months >= 6) return "â­";
    if (months >= 3) return "ðŸ”¥ðŸ”¥";
    if (months >= 2) return "ðŸ”¥";
    return "ðŸŒ±";
  }
  
  getStreakReward(milestone) {
    const rewards = {
      2: "Building Momentum Badge",
      3: "On Fire Badge",
      6: "Half Year Hero Badge",
      12: "Year Champion Badge",
      24: "Two Year Titan Badge",
      36: "Three Year Legend Badge"
    };
    return rewards[milestone] || "Epic Streak Badge";
  }
  
  async getNewBadges(userId, month) {
    const startDate = month.clone().startOf('month');
    const endDate = month.clone().endOf('month');
    
    const badges = await db.query(`
      SELECT 
        badge_type,
        earned_at,
        badge_name,
        badge_icon,
        badge_description
      FROM user_badges
      WHERE user_id = $1
      AND earned_at BETWEEN $2 AND $3
      ORDER BY earned_at DESC
    `, [userId, startDate.toDate(), endDate.toDate()]);
    
    return badges.rows.map(b => ({
      id: b.badge_type,
      name: b.badge_name,
      icon: b.badge_icon,
      description: b.badge_description,
      earned_at: b.earned_at
    }));
  }
  
  async getComparison(userId, month) {
    const currentMonth = month.clone();
    const lastMonth = month.clone().subtract(1, 'month');
    
    // Current month total
    const current = await db.query(`
      SELECT COALESCE(SUM(amount), 0) as total
      FROM donations
      WHERE user_id = $1
      AND created_at BETWEEN $2 AND $3
      AND status = 'succeeded'
    `, [
      userId,
      currentMonth.startOf('month').toDate(),
      currentMonth.endOf('month').toDate()
    ]);
    
    // Last month total
    const last = await db.query(`
      SELECT COALESCE(SUM(amount), 0) as total
      FROM donations
      WHERE user_id = $1
      AND created_at BETWEEN $2 AND $3
      AND status = 'succeeded'
    `, [
      userId,
      lastMonth.startOf('month').toDate(),
      lastMonth.endOf('month').toDate()
    ]);
    
    // Average
    const average = await db.query(`
      SELECT COALESCE(AVG(monthly_total), 0) as avg
      FROM (
        SELECT 
          DATE_TRUNC('month', created_at) as month,
          SUM(amount) as monthly_total
        FROM donations
        WHERE user_id = $1 AND status = 'succeeded'
        GROUP BY month
      ) monthly_totals
    `, [userId]);
    
    // Best month
    const best = await db.query(`
      SELECT 
        DATE_TRUNC('month', created_at) as month,
        SUM(amount) as total
      FROM donations
      WHERE user_id = $1 AND status = 'succeeded'
      GROUP BY month
      ORDER BY total DESC
      LIMIT 1
    `, [userId]);
    
    // Days since first donation
    const firstDonation = await db.query(`
      SELECT created_at
      FROM donations
      WHERE user_id = $1 AND status = 'succeeded'
      ORDER BY created_at ASC
      LIMIT 1
    `, [userId]);
    
    const currentTotal = parseFloat(current.rows[0].total);
    const lastTotal = parseFloat(last.rows[0].total);
    const avgTotal = parseFloat(average.rows[0].avg);
    const bestTotal = best.rows.length ? parseFloat(best.rows[0].total) : 0;
    
    const momChange = lastTotal > 0 
      ? ((currentTotal - lastTotal) / lastTotal) * 100 
      : 0;
    
    const vsAverage = avgTotal > 0
      ? ((currentTotal - avgTotal) / avgTotal) * 100
      : 0;
    
    const daysSince = firstDonation.rows.length
      ? moment().diff(moment(firstDonation.rows[0].created_at), 'days')
      : 0;
    
    return {
      vs_last_month: momChange,
      vs_average: vsAverage,
      best_month: bestTotal,
      is_new_record: currentTotal > bestTotal,
      days_since_first: daysSince
    };
  }
  
  async getImpactStories(userId, month) {
    // Get organizations user donated to this month
    const orgs = await db.query(`
      SELECT DISTINCT organization_id
      FROM donations
      WHERE user_id = $1
      AND DATE_TRUNC('month', created_at) = $2
      AND status = 'succeeded'
    `, [userId, month.startOf('month').toDate()]);
    
    const orgIds = orgs.rows.map(o => o.organization_id);
    
    if (orgIds.length === 0) return [];
    
    // Get recent impact stories from these organizations
    const stories = await db.query(`
      SELECT 
        o.name as organization,
        s.title,
        s.story_text,
        s.image_url,
        s.published_at
      FROM impact_stories s
      JOIN organizations o ON s.organization_id = o.id
      WHERE s.organization_id = ANY($1)
      AND s.published_at >= $2
      ORDER BY s.published_at DESC
      LIMIT 5
    `, [orgIds, month.startOf('month').toDate()]);
    
    return stories.rows.map(s => ({
      organization: s.organization,
      title: s.title,
      text: s.story_text,
      image: s.image_url
    }));
  }
  
  async getChallenges(userId, month) {
    // Get user's monthly challenges and their progress
    const challenges = await db.query(`
      SELECT 
        c.*,
        uc.progress,
        uc.completed,
        uc.completed_at
      FROM monthly_challenges c
      LEFT JOIN user_challenges uc ON c.id = uc.challenge_id AND uc.user_id = $1
      WHERE c.month = $2
      ORDER BY c.display_order
    `, [userId, month.format('YYYY-MM')]);
    
    return challenges.rows.map(c => ({
      id: c.id,
      name: c.name,
      description: c.description,
      icon: c.icon,
      goal: c.goal,
      progress: c.progress || 0,
      completed: c.completed || false,
      reward: c.reward
    }));
  }
  
  async storeReport(report) {
    await db.query(`
      INSERT INTO monthly_reports (
        user_id, month, report_data, generated_at
      ) VALUES ($1, $2, $3, $4)
      ON CONFLICT (user_id, month)
      DO UPDATE SET report_data = $3, generated_at = $4
    `, [
      report.user_id,
      report.month,
      JSON.stringify(report),
      report.generated_at
    ]);
  }
  
  async generateShareableUrl(userId, month) {
    // Generate shareable public URL for impact report
    const shareId = require('crypto').randomBytes(16).toString('hex');
    
    await db.query(`
      INSERT INTO shareable_reports (
        share_id, user_id, month, created_at
      ) VALUES ($1, $2, $3, NOW())
    `, [shareId, userId, month.format('YYYY-MM')]);
    
    return `${process.env.APP_URL}/share/${shareId}`;
  }
}

module.exports = ReportGenerator;
```

### 6.2 Badge Award System

```javascript
// services/badge_service.js

class BadgeService {
  /**
   * Check and award badges based on user activity
   */
  
  async checkAllBadges(userId) {
    const checks = [
      this.checkDonationCount(userId),
      this.checkMonthlyTotal(userId),
      this.checkStreak(userId),
      this.checkCountries(userId),
      this.checkCauses(userId),
      this.checkRecurring(userId),
      this.checkActions(userId),
      this.checkSocial(userId)
    ];
    
    const results = await Promise.all(checks);
    const newBadges = results.flat().filter(b => b !== null);
    
    // Award new badges
    for (const badge of newBadges) {
      await this.awardBadge(userId, badge);
    }
    
    return newBadges;
  }
  
  async checkDonationCount(userId) {
    const result = await db.query(`
      SELECT COUNT(*) as count
      FROM donations
      WHERE user_id = $1 AND status = 'succeeded'
    `, [userId]);
    
    const count = parseInt(result.rows[0].count);
    
    const badges = [];
    const milestones = [
      { count: 1, type: 'first_donation', name: 'First Donation', icon: 'ðŸŒ±' },
      { count: 5, type: 'consistent_5', name: 'Consistent Supporter', icon: 'ðŸŒ¿' },
      { count: 10, type: 'committed_10', name: 'Committed Helper', icon: 'ðŸŒ³' },
      { count: 25, type: 'maker_25', name: 'Change Maker', icon: 'ðŸŒ²' },
      { count: 50, type: 'champion_50', name: 'Impact Champion', icon: 'ðŸŒ´' },
      { count: 100, type: 'hero_100', name: 'Humanitarian Hero', icon: 'ðŸ†' }
    ];
    
    for (const milestone of milestones) {
      if (count >= milestone.count) {
        const hasIt = await this.hasBadge(userId, milestone.type);
        if (!hasIt) {
          badges.push(milestone);
        }
      }
    }
    
    return badges;
  }
  
  async checkMonthlyTotal(userId) {
    const thisMonth = moment().startOf('month');
    
    const result = await db.query(`
      SELECT SUM(amount) as total
      FROM donations
      WHERE user_id = $1
      AND created_at >= $2
      AND status = 'succeeded'
    `, [userId, thisMonth.toDate()]);
    
    const total = parseFloat(result.rows[0].total || 0);
    
    const levels = [
      { amount: 100, type: 'month_100', name: 'Monthly Champion', icon: 'ðŸ’¯' },
      { amount: 250, type: 'month_250', name: 'Monthly Hero', icon: 'ðŸ’«' },
      { amount: 500, type: 'month_500', name: 'Monthly Legend', icon: 'ðŸŒŸ' }
    ];
    
    for (const level of levels) {
      if (total >= level.amount) {
        const hasIt = await this.hasBadge(userId, `${level.type}_${thisMonth.format('YYYYMM')}`);
        if (!hasIt) {
          return [level];
        }
      }
    }
    
    return [];
  }
  
  async checkCountries(userId) {
    const result = await db.query(`
      SELECT COUNT(DISTINCT c.country_code) as count
      FROM donations d
      JOIN conflicts c ON d.conflict_id = c.id
      WHERE d.user_id = $1 AND d.status = 'succeeded'
    `, [userId]);
    
    const count = parseInt(result.rows[0].count);
    
    const badges = [];
    const milestones = [
      { count: 1, type: 'local_hero', name: 'Local Hero', icon: 'ðŸ“' },
      { count: 3, type: 'regional', name: 'Regional Helper', icon: 'ðŸ—ºï¸' },
      { count: 5, type: 'international', name: 'International Supporter', icon: 'ðŸŒ' },
      { count: 10, type: 'global', name: 'Global Citizen', icon: 'ðŸŒŽ' },
      { count: 20, type: 'world_changer', name: 'World Changer', icon: 'ðŸŒ' }
    ];
    
    for (const milestone of milestones) {
      if (count >= milestone.count) {
        const hasIt = await this.hasBadge(userId, milestone.type);
        if (!hasIt) {
          badges.push(milestone);
        }
      }
    }
    
    return badges;
  }
  
  async awardBadge(userId, badge) {
    await db.query(`
      INSERT INTO user_badges (
        user_id, badge_type, badge_name, badge_icon, earned_at
      ) VALUES ($1, $2, $3, $4, NOW())
      ON CONFLICT (user_id, badge_type) DO NOTHING
    `, [userId, badge.type, badge.name, badge.icon]);
    
    // Send notification
    await this.notifyBadgeEarned(userId, badge);
  }
  
  async hasBadge(userId, badgeType) {
    const result = await db.query(`
      SELECT 1 FROM user_badges
      WHERE user_id = $1 AND badge_type = $2
    `, [userId, badgeType]);
    
    return result.rows.length > 0;
  }
  
  async notifyBadgeEarned(userId, badge) {
    await notificationService.send(userId, {
      title: 'ðŸŽ‰ New Badge Unlocked!',
      body: `You earned the "${badge.name}" badge!`,
      data: {
        type: 'badge_earned',
        badge_type: badge.type
      }
    });
  }
}

module.exports = BadgeService;
```

---

## 7. Shareable Impact Cards

### 7.1 Generate Beautiful Share Images

```javascript
// services/share_card_generator.js
const { createCanvas, loadImage } = require('canvas');
const { Storage } = require('@google-cloud/storage');

class ShareCardGenerator {
  /**
   * Generate beautiful image cards for sharing impact
   */
  
  async generateImpactCard(userId, month) {
    const report = await this.getMonthlyReport(userId, month);
    
    // Create canvas
    const width = 1200;
    const height = 630; // Optimal for social media
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');
    
    // Background gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, '#2ECC71');
    gradient.addColorStop(1, '#27AE60');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    // Add pattern/texture
    await this.addTexture(ctx, width, height);
    
    // Main content
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 72px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`${report.monthly_total}`, width / 2, 200);
    
    ctx.font = '36px Arial';
    ctx.fillText('donated this month', width / 2, 260);
    
    // Stats row
    ctx.font = '28px Arial';
    const statsY = 380;
    
    ctx.fillText(`${report.donation_count} donations`, width / 4, statsY);
    ctx.fillText(`${report.countries_count} countries`, width / 2, statsY);
    ctx.fillText(`${report.streak} month streak`, (width / 4) * 3, statsY);
    
    // Branding
    ctx.font = 'bold 32px Arial';
    ctx.fillText('Making Impact Together', width / 2, height - 100);
    
    ctx.font = '24px Arial';
    ctx.fillText('humanitarian-app.com', width / 2, height - 50);
    
    // Convert to buffer
    const buffer = canvas.toBuffer('image/png');
    
    // Upload to cloud storage
    const url = await this.uploadImage(buffer, userId, month);
    
    return url;
  }
  
  async addTexture(ctx, width, height) {
    // Add subtle pattern/texture
    ctx.globalAlpha = 0.1;
    
    for (let i = 0; i < 100; i++) {
      ctx.beginPath();
      ctx.arc(
        Math.random() * width,
        Math.random() * height,
        Math.random() * 50,
        0,
        Math.PI * 2
      );
      ctx.fillStyle = '#FFFFFF';
      ctx.fill();
    }
    
    ctx.globalAlpha = 1.0;
  }
  
  async uploadImage(buffer, userId, month) {
    const storage = new Storage();
    const bucket = storage.bucket(process.env.SHARE_IMAGES_BUCKET);
    
    const fileName = `share/${userId}/${month}.png`;
    const file = bucket.file(fileName);
    
    await file.save(buffer, {
      metadata: { contentType: 'image/png' }
    });
    
    await file.makePublic();
    
    return `https://storage.googleapis.com/${process.env.SHARE_IMAGES_BUCKET}/${fileName}`;
  }
}

module.exports = ShareCardGenerator;
```

---

## 8. API Endpoints

```javascript
// routes/reports.js
const express = require('express# Impact Reporting & Gamification System

## 1. Gamification Philosophy: Self-Competition & Progress

### Core Principles
```yaml
Philosophy: "Compete with your past self, not others"

Key Motivators:
  - Personal growth tracking
  - Milestone achievements
  - Streak maintenance
  - Impact visualization
  - Habit formation
  - Emotional rewards (feel-good factor)

Avoid:
  - Public leaderboards (discouraging for small donors)
  - Donation amount comparisons between users
  - Guilt-based messaging
  - Pressure tactics
```

---

## 2. Gamification Elements

### 2.1 Progress Tracking Systems

#### Personal Milestones
```javascript
MILESTONES = {
  first_steps: {
    name: "First Steps",
    levels: [
      { donations: 1, reward: "First Donation Badge", icon: "ðŸŒ±" },
      { donations: 5, reward: "Consistent Supporter", icon: "ðŸŒ¿" },
      { donations: 10, reward: "Committed Helper", icon: "ðŸŒ³" },
      { donations: 25, reward: "Change Maker", icon: "ðŸŒ²" },
      { donations: 50, reward: "Impact Champion", icon: "ðŸŒ´" },
      { donations: 100, reward: "Humanitarian Hero", icon: "ðŸ†" }
    ]
  },
  
  monthly_totals: {
    name: "Monthly Impact",
    levels: [
      { amount: 10, reward: "Starter", color: "#95A5A6" },
      { amount: 25, reward: "Helper", color: "#3498DB" },
      { amount: 50, reward: "Supporter", color: "#9B59B6" },
      { amount: 100, reward: "Champion", color: "#E74C3C" },
      { amount: 250, reward: "Hero", color: "#F39C12" },
      { amount: 500, reward: "Legend", color: "#FFD700" }
    ]
  },
  
  donation_streaks: {
    name: "Consistency Streak",
    levels: [
      { months: 2, reward: "Building Momentum", icon: "ðŸ”¥" },
      { months: 3, reward: "On Fire!", icon: "ðŸ”¥ðŸ”¥" },
      { months: 6, reward: "Half Year Hero", icon: "â­" },
      { months: 12, reward: "Year Champion", icon: "ðŸ’«" },
      { months: 24, reward: "Two Year Titan", icon: "ðŸŒŸ" }
    ]
  },
  
  countries_supported: {
    name: "Global Impact",
    levels: [
      { countries: 1, reward: "Local Hero" },
      { countries: 3, reward: "Regional Helper" },
      { countries: 5, reward: "International Supporter" },
      { countries: 10, reward: "Global Citizen" },
      { countries: 20, reward: "World Changer" }
    ]
  },
  
  causes_supported: {
    name: "Diverse Impact",
    levels: [
      { causes: 2, reward: "Focused Helper" },
      { causes: 4, reward: "Multi-Cause Supporter" },
      { causes: 6, reward: "Humanitarian Generalist" },
      { causes: 8, reward: "Universal Supporter" }
    ]
  }
};
```

#### Personal Growth Metrics
```javascript
GROWTH_METRICS = {
  month_over_month: "Compare current month to last month",
  year_over_year: "This month vs same month last year",
  best_month: "Personal best donation month",
  longest_streak: "Longest consecutive donation streak",
  average_per_month: "Your average monthly impact",
  total_lifetime: "Total impact since joining"
};
```

### 2.2 Streak System

**Why Streaks Work:**
- Creates habit formation
- Fear of breaking streak (loss aversion)
- Visible progress
- Daily/monthly engagement

**Implementation:**
```javascript
class StreakSystem {
  calculateStreak(userId) {
    // Get all donation months
    const donations = getDonationsByMonth(userId);
    
    let currentStreak = 0;
    let longestStreak = 0;
    let tempStreak = 0;
    
    // Start from most recent month
    const today = new Date();
    let checkDate = new Date(today.getFullYear(), today.getMonth(), 1);
    
    // Count backwards
    while (checkDate >= userJoinDate) {
      const monthKey = `${checkDate.getFullYear()}-${checkDate.getMonth()}`;
      
      if (donations[monthKey]) {
        tempStreak++;
        if (checkDate.getMonth() === today.getMonth()) {
          currentStreak = tempStreak;
        }
      } else {
        if (tempStreak > longestStreak) {
          longestStreak = tempStreak;
        }
        tempStreak = 0;
      }
      
      checkDate.setMonth(checkDate.getMonth() - 1);
    }
    
    return {
      current: currentStreak,
      longest: Math.max(longestStreak, tempStreak),
      isActive: currentStreak > 0,
      nextMilestone: getNextStreakMilestone(currentStreak)
    };
  }
  
  getStreakEmoji(months) {
    if (months >= 12) return "ðŸ’«";
    if (months >= 6) return "â­";
    if (months >= 3) return "ðŸ”¥ðŸ”¥";
    if (months >= 2) return "ðŸ”¥";
    return "ðŸŒ±";
  }
}
```

### 2.3 Challenge System (Monthly)

**Personal Challenges (opt-in):**
```javascript
MONTHLY_CHALLENGES = {
  consistency: {
    name: "Stay Consistent",
    description: "Donate at least once this month",
    reward: "100 impact points",
    type: "binary"
  },
  
  increase_amount: {
    name: "Level Up",
    description: "Donate 10% more than last month",
    reward: "Streak Saver token (forgives one missed month)",
    type: "percentage"
  },
  
  new_country: {
    name: "Expand Horizons",
    description: "Support a new country this month",
    reward: "Explorer Badge",
    type: "discovery"
  },
  
  recurring_setup: {
    name: "Go Recurring",
    description: "Set up a monthly recurring donation",
    reward: "500 impact points + Steady Supporter Badge",
    type: "action"
  },
  
  share_impact: {
    name: "Inspire Others",
    description: "Share your impact story on social media",
    reward: "Influencer Badge",
    type: "social"
  },
  
  take_action: {
    name: "Beyond Donations",
    description: "Sign a petition or attend a protest",
    reward: "Activist Badge",
    type: "engagement"
  }
};
```

### 2.4 Impact Points System

**Purpose:** Quantify non-monetary contributions

```javascript
POINTS_EARNING = {
  // Donations
  donation_1_25: 10,
  donation_25_50: 25,
  donation_50_100: 50,
  donation_100_plus: (amount) => amount * 0.5,
  recurring_setup: 200,
  
  // Engagement
  profile_view: 1,
  swipe_up: 2,
  share_conflict: 10,
  share_impact: 15,
  
  // Actions
  sign_petition: 25,
  attend_protest: 50,
  contact_representative: 30,
  
  // Social
  invite_friend: 100,
  friend_donates: 250,
  
  // Streaks
  streak_month: 50,
  streak_bonus_3months: 150,
  streak_bonus_6months: 500,
  streak_bonus_12months: 1500,
  
  // Learning
  read_article: 5,
  watch_video: 10,
  complete_quiz: 20
};

POINTS_REDEMPTION = {
  streak_saver: 500, // Forgive one missed month
  impact_boost: 200, // 2x points next week
  priority_matching: 300, // Get first access to urgent conflicts
  custom_badge: 1000, // Design your own badge
  donor_spotlight: 2000 // Featured in monthly newsletter
};
```

---

## 3. Technology Stack

### 3.1 Data Visualization

```yaml
Primary Library: React Native Skia (RECOMMENDED)
  - Native performance (60fps+)
  - Beautiful animations
  - Custom charts/graphics
  - GPU-accelerated
  Package: @shopify/react-native-skia

Alternative: Victory Native
  - Pre-built chart components
  - Easier to use
  - Good for standard charts
  Package: victory-native

For Web Dashboard: D3.js + Recharts
  - D3 for custom visualizations
  - Recharts for standard charts
  - Excellent documentation

Animation Library: React Native Reanimated 3
  - Smooth 60fps animations
  - Gesture-based interactions
  - Worklet support
  Package: react-native-reanimated

Progress Indicators: React Native Progress
  - Circles, bars, pies
  - Animated
  Package: react-native-progress

Confetti/Celebrations: React Native Confetti Cannon
  - For milestone achievements
  Package: react-native-confetti-cannon

Lottie Animations: @lottiefiles/react-native
  - Pre-made celebration animations
  - Small file size
```

### 3.2 Backend

```yaml
Data Processing:
  - Node.js + Express (API)
  - PostgreSQL (data storage)
  - Redis (caching, real-time updates)
  
Analytics:
  - Mixpanel or Amplitude (user behavior)
  - Custom analytics pipeline
  
Report Generation:
  - Bull (job queue)
  - node-cron (scheduling)
  - Sharp (image generation for shares)
  
Push Notifications:
  - Firebase Cloud Messaging
  - OneSignal (alternative)
```

### 3.3 Real-Time Features

```yaml
Real-Time Updates:
  - Socket.io or Firebase Realtime Database
  - Live impact counter
  - Instant badge unlocks
  
Progressive Web App:
  - Share impact reports as web pages
  - Beautiful shareable cards
```

---

## 4. Report Components Design

### 4.1 Monthly Report Structure

```javascript
MONTHLY_REPORT_SECTIONS = {
  hero: {
    name: "Impact Hero Section",
    components: [
      "Animated impact number",
      "Month-over-month change",
      "Motivational message",
      "Streak indicator"
    ]
  },
  
  milestones: {
    name: "Achievements Unlocked",
    components: [
      "New badges earned",
      "Progress to next milestone",
      "Lifetime achievements"
    ]
  },
  
  breakdown: {
    name: "Your Impact Breakdown",
    components: [
      "Donations by country (map)",
      "Donations by cause (pie chart)",
      "Donation timeline (line chart)",
      "Organizations supported (list)"
    ]
  },
  
  stories: {
    name: "Impact Stories",
    components: [
      "Real stories from the field",
      "How your donation helped",
      "Matched with your interests"
    ]
  },
  
  comparison: {
    name: "Your Progress",
    components: [
      "This month vs last month",
      "This month vs your average",
      "Your best month ever",
      "Days since first donation"
    ]
  },
  
  forecast: {
    name: "Looking Ahead",
    components: [
      "Next milestone preview",
      "Monthly challenges available",
      "Suggested actions",
      "Projected annual impact"
    ]
  }
};
```

### 4.2 Interactive Visualizations

#### Animated Impact Counter
```javascript
// components/AnimatedImpactCounter.js
import React, { useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  Easing
} from 'react-native-reanimated';

export default function AnimatedImpactCounter({ value, prefix = '$', duration = 2000 }) {
  const animatedValue = useSharedValue(0);

  useEffect(() => {
    animatedValue.value = withTiming(value, {
      duration: duration,
      easing: Easing.bezier(0.25, 0.1, 0.25, 1)
    });
  }, [value]);

  const animatedProps = useAnimatedProps(() => {
    return {
      text: `${prefix}${Math.floor(animatedValue.value).toLocaleString()}`
    };
  });

  return (
    <View style={styles.container}>
      <AnimatedText animatedProps={animatedProps} style={styles.number} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  number: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#2ECC71'
  }
});
```

#### Interactive World Map
```javascript
// components/ImpactWorldMap.js
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import Svg, { Path, Circle, Text as SvgText } from 'react-native-svg';
import Animated, { useAnimatedProps, withSpring } from 'react-native-reanimated';

export default function ImpactWorldMap({ donations }) {
  /**
   * Show animated arcs from user location to donation countries
   * Countries glow based on donation amount
   */
  
  const [selectedCountry, setSelectedCountry] = React.useState(null);
  
  // World map paths (simplified)
  const worldMapPath = "M 0,0 ... your SVG world map path ...";
  
  return (
    <View style={styles.container}>
      <Svg width="100%" height="400" viewBox="0 0 1000 500">
        {/* Base world map */}
        <Path
          d={worldMapPath}
          fill="#E0E0E0"
          stroke="#999"
          strokeWidth="0.5"
        />
        
        {/* Donation markers */}
        {donations.map((donation, index) => (
          <AnimatedDonationMarker
            key={donation.country}
            country={donation.country}
            amount={donation.amount}
            coordinates={donation.coordinates}
            onPress={() => setSelectedCountry(donation)}
            delay={index * 100}
          />
        ))}
        
        {/* Connection lines from user to countries */}
        {donations.map((donation, index) => (
          <AnimatedArc
            key={`arc-${donation.country}`}
            from={userLocation}
            to={donation.coordinates}
            delay={index * 150}
          />
        ))}
      </Svg>
      
      {selectedCountry && (
        <CountryDetailPopup
          country={selectedCountry}
          onClose={() => setSelectedCountry(null)}
        />
      )}
    </View>
  );
}

function AnimatedDonationMarker({ country, amount, coordinates, onPress, delay }) {
  const scale = useSharedValue(0);
  const opacity = useSharedValue(0);
  
  useEffect(() => {
    scale.value = withSpring(1, { delay });
    opacity.value = withTiming(1, { duration: 500, delay });
  }, []);
  
  // Marker size based on amount
  const radius = Math.min(5 + Math.log(amount) * 2, 20);
  
  const animatedProps = useAnimatedProps(() => ({
    r: radius * scale.value,
    opacity: opacity.value
  }));
  
  return (
    <TouchableOpacity onPress={onPress}>
      <AnimatedCircle
        cx={coordinates.x}
        cy={coordinates.y}
        fill="#E74C3C"
        animatedProps={animatedProps}
      />
      
      {/* Pulse effect */}
      <AnimatedPulse
        cx={coordinates.x}
        cy={coordinates.y}
        initialRadius={radius}
      />
    </TouchableOpacity>
  );
}
```

#### Progress Ring with Milestones
```javascript
// components/ProgressRing.js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Svg, { Circle, Text as SvgText } from 'react-native-svg';
import Animated, { useAnimatedProps, withTiming } from 'react-native-reanimated';

export default function ProgressRing({ 
  current, 
  goal, 
  size = 200,
  strokeWidth = 20,
  color = '#2ECC71'
}) {
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const progress = (current / goal) * 100;
  
  const animatedProps = useAnimatedProps(() => {
    const strokeDashoffset = circumference - (progress / 100) * circumference;
    
    return {
      strokeDashoffset: withTiming(strokeDashoffset, { duration: 1500 })
    };
  });
  
  return (
    <View style={styles.container}>
      <Svg width={size} height={size}>
        {/* Background circle */}
        <Circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="#E0E0E0"
          strokeWidth={strokeWidth}
          fill="none"
        />
        
        {/* Progress circle */}
        <AnimatedCircle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke={color}
          strokeWidth={strokeWidth}
          fill="none"
          strokeDasharray={circumference}
          animatedProps={animatedProps}
          strokeLinecap="round"
          transform={`rotate(-90 ${size / 2} ${size / 2})`}
        />
        
        {/* Center text */}
        <SvgText
          x={size / 2}
          y={size / 2}
          textAnchor="middle"
          fontSize="32"
          fontWeight="bold"
          fill={color}
        >
          {Math.round(progress)}%
        </SvgText>
        
        <SvgText
          x={size / 2}
          y={size / 2 + 25}
          textAnchor="middle"
          fontSize="14"
          fill="#666"
        >
          ${current} of ${goal}
        </SvgText>
      </Svg>
      
      <Text style={styles.label}>Next Milestone: Hero Level</Text>
    </View>
  );
}
```

#### Donation Timeline Chart
```javascript
// components/DonationTimeline.js
import React from 'react';
import { View, Dimensions } from 'react-native';
import { LineChart } from 'react-native-chart-kit';

export default function DonationTimeline({ data }) {
  const screenWidth = Dimensions.get('window').width;
  
  return (
    <LineChart
      data={{
        labels: data.months,
        datasets: [
          {
            data: data.amounts,
            color: (opacity = 1) => `rgba(46, 204, 113, ${opacity})`,
            strokeWidth: 3
          }
        ]
      }}
      width={screenWidth - 40}
      height={220}
      chartConfig={{
        backgroundColor: '#fff',
        backgroundGradientFrom: '#fff',
        backgroundGradientTo: '#fff',
        decimalPlaces: 0,
        color: (opacity = 1) => `rgba(46, 204, 113, ${opacity})`,
        labelColor: (opacity = 1) => `rgba(0, 0, 0, ${opacity})`,
        style: {
          borderRadius: 16
        },
        propsForDots: {
          r: '6',
          strokeWidth: '2',
          stroke: '#2ECC71'
        }
      }}
      bezier
      style={{
        marginVertical: 8,
        borderRadius: 16
      }}
      withInnerLines={false}
      withOuterLines={true}
      withVerticalLabels={true}
      withHorizontalLabels={true}
    />
  );
}
```

---

## 5. Complete Monthly Report Screen

```javascript
// screens/MonthlyReportScreen.js
import React, { useState, useEffect } from 'react';
import { 
  View, 
  ScrollView, 
  StyleSheet, 
  Share,
  TouchableOpacity,
  Animated
} from 'react-native';
import { Text, Button, Card } from 'react-native-paper';
import ConfettiCannon from 'react-native-confetti-cannon';
import LottieView from '@lottiefiles/react-native';

export default function MonthlyReportScreen({ navigation }) {
  const [report, setReport] = useState(null);
  const [showConfetti, setShowConfetti] = useState(false);
  const [newBadges, setNewBadges] = useState([]);
  
  useEffect(() => {
    fetchMonthlyReport();
  }, []);
  
  const fetchMonthlyReport = async () => {
    const response = await fetch('/api/reports/monthly');
    const data = await response.json();
    setReport(data);
    
    // Show confetti if new badges earned
    if (data.new_badges.length > 0) {
      setNewBadges(data.new_badges);
      setShowConfetti(true);
    }
  };
  
  const handleShare = async () => {
    const message = generateShareMessage(report);
    await Share.share({
      message: message,
      url: report.shareable_url
    });
  };
  
  if (!report) {
    return <LoadingScreen />;
  }
  
  return (
    <ScrollView style={styles.container}>
      {/* Confetti for achievements */}
      {showConfetti && (
        <ConfettiCannon
          count={200}
          origin={{ x: -10, y: 0 }}
          autoStart={true}
          fadeOut={true}
          onAnimationEnd={() => setShowConfetti(false)}
        />
      )}
      
      {/* Hero Section */}
      <HeroSection report={report} />
      
      {/* New Badges */}
      {newBadges.length > 0 && (
        <BadgesUnlockedSection badges={newBadges} />
      )}
      
      {/* Impact Summary */}
      <ImpactSummarySection report={report} />
      
      {/* Streak Tracker */}
      <StreakSection streak={report.streak} />
      
      {/* World Map */}
      <Card style={styles.card}>
        <Card.Content>
          <Text style={styles.sectionTitle}>Your Global Impact</Text>
          <ImpactWorldMap donations={report.donations_by_country} />
        </Card.Content>
      </Card>
      
      {/* Timeline */}
      <Card style={styles.card}>
        <Card.Content>
          <Text style={styles.sectionTitle}>Donation Trend</Text>
          <DonationTimeline data={report.timeline} />
        </Card.Content>
      </Card>
      
      {/* Progress Rings */}
      <ProgressSection milestones={report.milestones} />
      
      {/* Impact Stories */}
      <ImpactStoriesSection stories={report.impact_stories} />
      
      {/* Personal Comparison */}
      <ComparisonSection comparison={report.comparison} />
      
      {/* Monthly Challenges */}
      <ChallengesSection challenges={report.challenges} />
      
      {/* Next Steps */}
      <NextStepsSection suggestions={report.suggestions} />
      
      {/* Share Button */}
      <Button
        mode="contained"
        onPress={handleShare}
        icon="share"
        style={styles.shareButton}
      >
        Share Your Impact
      </Button>
    </ScrollView>
  );
}

function HeroSection({ report }) {
  return (
    <View style={styles.hero}>
      <LottieView
        source={require('../assets/animations/celebration.json')}
        autoPlay
        loop={false}
        style={styles.celebration}
      />
      
      <Text style={styles.heroGreeting}>
        Amazing work, {report.user_name}!
      </Text>
      
      <AnimatedImpactCounter
        value={report.monthly_total}
        prefix="$"
      />
      
      <Text style={styles.heroSubtext}>
        donated this month
      </Text>
      
      {/* Month-over-month change */}
      <View style={styles.changeIndicator}>
        {report.month_over_month_change > 0 ? (
          <>
            <Text style={styles.changeUp}>
              â†‘ {report.month_over_month_change}%
            </Text>
            <Text style={styles.changeText}>
              more than last month!
            </Text>
          </>
        ) : report.month_over_month_change === 0 ? (
          <Text style={styles.changeText}>
            Same as last month - Staying consistent! ðŸ”¥
          </Text>
        ) : (
          <Text style={styles.changeText}>
            Every bit helps - Keep going! ðŸ’ª
          </Text>
        )}
      </View>
    </View>
  );
}

function BadgesUnlockedSection({ badges }) {
  return (
    <Card style={[styles.card, styles.badgesCard]}>
      <Card.Content>
        <Text style={styles.sectionTitle}>ðŸŽ‰ New Achievements Unlocked!</Text>
        
        <View style={styles.badgesGrid}>
          {badges.map((badge, index) => (
            <BadgeCard
              key={badge.id}
              badge={badge}
              delay={index * 200}
            />
          ))}
        </View>
      </Card.Content>
    </Card>
  );
}

function BadgeCard({ badge, delay }) {
  const scaleAnim = new Animated.Value(0);
  
  useEffect(() => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      delay: delay,
      tension: 50,
      friction: 7,
      useNativeDriver: true
    }).start();
  }, []);
  
  return (
    <Animated.View style={[
      styles.badgeCard,
      { transform: [{ scale: scaleAnim }] }
    ]}>
      <Text style={styles.badgeEmoji}>{badge.icon}</Text>
      <Text style={styles.badgeName}>{badge.name}</Text>
      <Text style={styles.badgeDescription}>{badge.description}</Text>
    </Animated.View>
  );
}

function StreakSection({ streak }) {
  return (
    <Card style={styles.card}>
      <Card.Content>
        <Text style={styles.sectionTitle}>Your Streak {streak.emoji}</Text>
        
        <View style={styles.streakContainer}>
          <View style={styles.streakCurrent}>
            <Text style={styles.streakNumber}>{streak.current}</Text>
            <Text style={styles.streakLabel}>months in a row</Text>
          </View>
          
          {streak.isActive && (
            <View style={styles.streakIndicator}>
              <Text style={styles.streakActive}>ACTIVE STREAK!</Text>
            </View>
          )}
        </View>
        
        <View style={styles.streakMilestone}>
          <ProgressBar
            progress={streak.current / streak.next_milestone}
            color="#F39C12"
          />
          <Text style={styles.streakMilestoneText}>
            {streak.next_milestone - streak.current} months until {streak.next_reward}
          </Text>
        </View>
        
        {streak.longest > streak.current && (
          <Text style={styles.streakRecord}>
            Your record: {streak.longest} months
          </Text>
        )}
      </Card.Content>
    </Card>
  );
}

function ImpactStoriesSection({ stories }) {
  const [currentStory, setCurrentStory] = useState(0);
  
  return (
    <Card style={styles.card}>
      <Card.Content>
        <Text style={styles.sectionTitle}>How You Helped</Text>
        
        <View style={styles.storyContainer}>
          <Image
            source={{ uri: stories[currentStory].image }}
            style={styles.storyImage}
          />
          
          <Text style={styles.storyText}>
            {stories[currentStory].text}
          </Text>
          
          <Text style={styles.storyOrg}>
            â€” {stories[currentStory].organization}
          </Text>
          
          {/* Story pagination */}
          <View style={styles.storyDots}>
            {stories.map((_, index) => (
              <TouchableOpacity
                key={index}
                onPress={() => setCurrentStory(index)}
              >
                <View style={[
                  styles.dot,
                  index === currentStory && styles.dotActive
                ]} />
              </TouchableOpacity>
            ))}
          </View>
        </View>
      </Card.Content>
    </Card>
  );
}

function ComparisonSection({ comparison }) {
  return (
    <Card style={styles.card}>
      <Card.Content>
        <Text style={styles.sectionTitle}>Your Progress</Text>
        
        <View style={styles.comparisonGrid}>
          <ComparisonStat
            label="vs Last Month"
            value={comparison.vs_last_month}
            format="percentage"
          />
          
          <ComparisonStat
            label="vs Your Average"
            value={comparison.vs_average}
            format="percentage"
          />
          
          <ComparisonStat
            label="Best Month Ever"
            value={comparison.best_month}
            format="currency"
            isRecord={comparison.is_new_record}
          />
          
          <ComparisonStat
            label="Days Contributing"
            value={comparison.days_since_first}
            format="number"
            suffix=" days"
          />
        </View>
      </Card.Content>
    </Card>
  );
}

function ChallengesSection({ challenges }) {
  return (
    <Card style={styles.card}>
      <Card.Content>
        <Text style={styles.sectionTitle}>This Month's Challenges</Text>
        
        {challenges.map(challenge => (
          <ChallengeCard
            key={challenge.id}
            challenge={challenge}
          />
        ))}
      </Card.Content>
    </Card>
  );
}

function ChallengeCard({ challenge }) {
  return (
    <View style={styles.challengeCard}>
      <View style={styles.challengeHeader}>