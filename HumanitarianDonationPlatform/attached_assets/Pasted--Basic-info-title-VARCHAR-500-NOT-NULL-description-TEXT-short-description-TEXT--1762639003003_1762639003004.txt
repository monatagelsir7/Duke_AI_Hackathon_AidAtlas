-- Basic info
    title VARCHAR(500) NOT NULL,
    description TEXT,
    short_description TEXT, -- AI-generated summary
    
    -- Location (for protests/events)
    location_name VARCHAR(255),
    address TEXT,
    city VARCHAR(100),
    state VARCHAR(50),
    country VARCHAR(100),
    latitude DECIMAL(10, 8),
    longitude DECIMAL(11, 8),
    
    -- Timing
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    timezone VARCHAR(50),
    
    -- Organizer/Creator
    organizer_name VARCHAR(255),
    organizer_description TEXT,
    organizer_url TEXT,
    
    -- Petition-specific
    target VARCHAR(255), -- Who petition is addressed to
    signature_count INTEGER,
    signature_goal INTEGER,
    
    -- Advocacy-specific
    representatives JSONB, -- List of relevant representatives
    talking_points JSONB,
    
    -- Conflict relevance
    related_conflicts UUID[], -- Array of conflict IDs
    related_country VARCHAR(3), -- ISO country code
    tags TEXT[], -- humanitarian, refugee, medical, etc.
    
    -- Engagement
    url TEXT NOT NULL,
    is_free BOOLEAN DEFAULT true,
    capacity INTEGER,
    current_attendance INTEGER,
    
    -- AI-enhanced content
    enhanced_description JSONB, -- AI-generated content
    
    -- Status
    status VARCHAR(50) DEFAULT 'active', -- active, completed, cancelled
    verification_status VARCHAR(50) DEFAULT 'unverified', -- verified, unverified, flagged
    
    -- Metadata
    scraped_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Geospatial index for location queries
CREATE INDEX idx_actions_location ON actions USING GIST(
    ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)::geography
);

-- Indexes for filtering
CREATE INDEX idx_actions_type ON actions(type);
CREATE INDEX idx_actions_status ON actions(status);
CREATE INDEX idx_actions_start_time ON actions(start_time);
CREATE INDEX idx_actions_related_country ON actions(related_country);
CREATE INDEX idx_actions_tags ON actions USING GIN(tags);

-- User action participation tracking
CREATE TABLE user_action_participation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    action_id UUID REFERENCES actions(id) ON DELETE CASCADE,
    
    -- Participation type
    participation_type VARCHAR(50), -- attended, signed, contacted, shared
    
    -- User contribution
    personal_message TEXT, -- For advocacy: their customized message
    
    -- Status
    status VARCHAR(50), -- interested, committed, completed
    reminded BOOLEAN DEFAULT false,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    
    UNIQUE(user_id, action_id)
);

-- User reminders for actions
CREATE TABLE action_reminders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    action_id UUID REFERENCES actions(id) ON DELETE CASCADE,
    
    reminder_time TIMESTAMP NOT NULL,
    reminder_type VARCHAR(50), -- 1_day_before, 1_hour_before, custom
    sent BOOLEAN DEFAULT false,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, action_id, reminder_type)
);

-- Action reports/flags
CREATE TABLE action_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    action_id UUID REFERENCES actions(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    
    report_type VARCHAR(50), -- spam, inappropriate, misinformation, cancelled
    description TEXT,
    
    status VARCHAR(50) DEFAULT 'pending', -- pending, reviewed, resolved
    reviewed_by UUID REFERENCES admin_users(id),
    reviewed_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Campaign templates (for advocacy)
CREATE TABLE advocacy_campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conflict_id UUID REFERENCES conflicts(id) ON DELETE CASCADE,
    
    title VARCHAR(255) NOT NULL,
    issue VARCHAR(255),
    specific_ask TEXT,
    
    -- Target
    target_level VARCHAR(50), -- local, state, federal, international
    target_committees TEXT[], -- Congressional committees
    
    -- Template
    message_template TEXT,
    talking_points JSONB,
    
    -- Status
    is_active BOOLEAN DEFAULT true,
    start_date DATE,
    end_date DATE,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_user_participation_user ON user_action_participation(user_id);
CREATE INDEX idx_user_participation_action ON user_action_participation(action_id);
CREATE INDEX idx_action_reminders_time ON action_reminders(reminder_time) WHERE NOT sent;
```

---

## 7. Action Discovery Pipeline (Automated)

```javascript
// pipeline/action_discovery_pipeline.js
const EventbriteService = require('../services/eventbrite_service');
const MeetupService = require('../services/meetup_service');
const ChangeOrgService = require('../services/change_org_service');
const ActionNetworkService = require('../services/action_network_service');
const GrassrootsEventScraper = require('../scrapers/grassroots_scraper');
const ActionEnhancer = require('../services/action_enhancer');

class ActionDiscoveryPipeline {
  /**
   * Automated pipeline to discover and process actions
   */
  
  constructor(db) {
    this.db = db;
    this.eventbrite = new EventbriteService(process.env.EVENTBRITE_API_KEY);
    this.meetup = new MeetupService(process.env.MEETUP_API_KEY);
    this.changeOrg = new ChangeOrgService(process.env.CHANGE_ORG_API_KEY);
    this.actionNetwork = new ActionNetworkService(process.env.ACTION_NETWORK_API_KEY);
    this.grassrootsScraper = new GrassrootsEventScraper();
    this.enhancer = new ActionEnhancer(process.env.ANTHROPIC_API_KEY);
  }

  async runDiscovery() {
    /**
     * Run complete discovery pipeline
     * Should be scheduled to run every 6-12 hours
     */
    
    console.log('ðŸ” Starting action discovery pipeline...');
    
    // Get active conflicts to search for
    const conflicts = await this.getActiveConflicts();
    
    let totalActionsFound = 0;
    
    for (const conflict of conflicts) {
      console.log(`\nðŸ“ Searching actions for: ${conflict.country_name}`);
      
      // Generate search parameters
      const searchParams = this.generateSearchParams(conflict);
      
      // Search all sources
      const actions = await Promise.all([
        this.searchProtests(searchParams),
        this.searchPetitions(searchParams),
        this.searchGrassroots(searchParams)
      ]);
      
      // Flatten and deduplicate
      const allActions = actions.flat();
      const uniqueActions = this.deduplicateActions(allActions);
      
      console.log(`   Found ${uniqueActions.length} unique actions`);
      
      // Process each action
      for (const action of uniqueActions) {
        await this.processAction(action, conflict);
        totalActionsFound++;
      }
    }
    
    console.log(`\nâœ… Discovery complete! Found ${totalActionsFound} total actions`);
    
    return totalActionsFound;
  }

  async getActiveConflicts() {
    /**
     * Get conflicts that need action discovery
     */
    
    const result = await this.db.query(`
      SELECT id, country_code, country_name, tags, summary
      FROM conflicts
      WHERE is_active = true
      AND current_status IN ('active', 'escalating')
      ORDER BY last_updated DESC
    `);
    
    return result.rows;
  }

  generateSearchParams(conflict) {
    /**
     * Generate search parameters based on conflict
     */
    
    const baseKeywords = [
      conflict.country_name,
      'humanitarian',
      'solidarity',
      'support',
      'aid',
      'protest'
    ];
    
    // Add conflict-specific keywords
    const tags = conflict.tags || [];
    const additionalKeywords = tags.map(tag => {
      const keywordMap = {
        'refugees': ['refugee', 'asylum'],
        'children': ['children', 'kids', 'youth'],
        'medical': ['medical', 'health', 'healthcare'],
        'food': ['hunger', 'food security', 'nutrition']
      };
      return keywordMap[tag] || [tag];
    }).flat();
    
    return {
      keywords: [...baseKeywords, ...additionalKeywords],
      country: conflict.country_code,
      tags: tags
    };
  }

  async searchProtests(searchParams) {
    /**
     * Search for protests across multiple platforms
     */
    
    const protests = [];
    
    // Search Eventbrite
    try {
      const eventbriteResults = await this.eventbrite.searchEvents({
        keywords: searchParams.keywords,
        location: { lat: 40.7128, lon: -74.0060, radius: '500km' }, // Major city as center
        start_date: new Date().toISOString()
      });
      protests.push(...eventbriteResults);
    } catch (error) {
      console.error('Eventbrite search error:', error);
    }
    
    // Search Meetup
    try {
      const meetupResults = await this.meetup.searchEvents({
        keywords: searchParams.keywords,
        location: { lat: 40.7128, lon: -74.0060, radius: 500 }
      });
      protests.push(...meetupResults);
    } catch (error) {
      console.error('Meetup search error:', error);
    }
    
    return protests;
  }

  async searchPetitions(searchParams) {
    /**
     * Search for petitions
     */
    
    const petitions = [];
    
    // Search Change.org
    try {
      const changeOrgResults = await this.changeOrg.searchPetitions(
        searchParams.keywords,
        searchParams.country
      );
      petitions.push(...changeOrgResults);
    } catch (error) {
      console.error('Change.org search error:', error);
    }
    
    // Search Action Network
    try {
      const actionNetworkResults = await this.actionNetwork.getPetitions();
      // Filter by relevance
      const relevant = actionNetworkResults.filter(p => 
        searchParams.keywords.some(kw => 
          p.title.toLowerCase().includes(kw.toLowerCase())
        )
      );
      petitions.push(...relevant);
    } catch (error) {
      console.error('Action Network search error:', error);
    }
    
    return petitions;
  }

  async searchGrassroots(searchParams) {
    /**
     * Scrape grassroots websites
     */
    
    try {
      const grassrootsEvents = await this.grassrootsScraper.scrapeAll();
      
      // Filter by relevance
      const relevant = grassrootsEvents.filter(event =>
        searchParams.keywords.some(kw =>
          event.title.toLowerCase().includes(kw.toLowerCase()) ||
          event.description.toLowerCase().includes(kw.toLowerCase())
        )
      );
      
      return relevant;
    } catch (error) {
      console.error('Grassroots scraping error:', error);
      return [];
    }
  }

  deduplicateActions(actions) {
    /**
     * Remove duplicate actions based on title and location similarity
     */
    
    const unique = [];
    const seen = new Set();
    
    for (const action of actions) {
      // Create fingerprint
      const fingerprint = this.createFingerprint(action);
      
      if (!seen.has(fingerprint)) {
        seen.add(fingerprint);
        unique.push(action);
      }
    }
    
    return unique;
  }

  createFingerprint(action) {
    /**
     * Create unique fingerprint for action
     */
    
    const titleNormalized = action.title.toLowerCase()
      .replace(/[^a-z0-9]/g, '')
      .substring(0, 50);
    
    const locationKey = action.location?.latitude && action.location?.longitude
      ? `${action.location.latitude.toFixed(2)},${action.location.longitude.toFixed(2)}`
      : action.location?.address || 'online';
    
    const dateKey = action.start_time 
      ? new Date(action.start_time).toISOString().split('T')[0]
      : 'ongoing';
    
    return `${titleNormalized}_${locationKey}_${dateKey}`;
  }

  async processAction(action, conflict) {
    /**
     * Process and store action with AI enhancement
     */
    
    try {
      // Check if action already exists
      const existing = await this.db.query(
        'SELECT id FROM actions WHERE external_id = $1 AND source = $2',
        [action.id, action.source]
      );
      
      if (existing.rows.length > 0) {
        // Update existing
        await this.updateExistingAction(existing.rows[0].id, action);
        return;
      }
      
      // Enhance with AI
      let enhancedDescription = null;
      
      if (action.type === 'protest') {
        enhancedDescription = await this.enhancer.enhanceProtestDescription(
          action,
          conflict
        );
      } else if (action.type === 'petition') {
        enhancedDescription = await this.enhancer.enhancePetitionDescription(
          action,
          conflict
        );
      }
      
      // Store in database
      await this.db.query(`
        INSERT INTO actions (
          external_id, source, type, title, description, short_description,
          location_name, address, city, state, country, latitude, longitude,
          start_time, end_time, timezone,
          organizer_name, organizer_description, organizer_url,
          target, signature_count, signature_goal,
          related_conflicts, related_country, tags,
          url, is_free, capacity,
          enhanced_description,
          status, verification_status
        ) VALUES (
          $1, $2, $3, $4, $5, $6,
          $7, $8, $9, $10, $11, $12, $13,
          $14, $15, $16,
          $17, $18, $19,
          $20, $21, $22,
          $23, $24, $25,
          $26, $27, $28,
          $29,
          $30, $31
        )
      `, [
        action.id,
        action.source,
        action.type,
        action.title,
        action.description,
        enhancedDescription?.short_description,
        action.location?.name,
        action.location?.address,
        action.location?.city,
        action.location?.state,
        action.location?.country,
        action.location?.latitude,
        action.location?.longitude,
        action.start_time,
        action.end_time,
        action.timezone,
        action.organizer?.name,
        action.organizer?.description,
        action.organizer?.url,
        action.target,
        action.signature_count,
        action.signature_goal,
        [conflict.id],
        conflict.country_code,
        conflict.tags,
        action.url,
        action.is_free,
        action.capacity,
        JSON.stringify(enhancedDescription),
        'active',
        'unverified'
      ]);
      
      console.log(`   âœ“ Added: ${action.title}`);
      
    } catch (error) {
      console.error(`Error processing action: ${error.message}`);
    }
  }

  async updateExistingAction(actionId, newData) {
    /**
     * Update existing action with new data
     */
    
    await this.db.query(`
      UPDATE actions
      SET 
        title = $2,
        description = $3,
        signature_count = $4,
        current_attendance = $5,
        last_updated = NOW()
      WHERE id = $1
    `, [
      actionId,
      newData.title,
      newData.description,
      newData.signature_count,
      newData.attendance
    ]);
  }
}

module.exports = ActionDiscoveryPipeline;
```

---

## 8. API Endpoints

```javascript
// routes/actions.js
const express = require('express');
const router = express.Router();
const ActionMatcher = require('../services/action_matcher');
const CongressService = require('../services/congress_service');

// Get actions for a specific conflict
router.get('/api/actions/conflict/:conflictId', async (req, res) => {
  const { conflictId } = req.params;
  const userId = req.user.id; // From auth middleware
  const limit = parseInt(req.query.limit) || 10;
  
  try {
    const matcher = new ActionMatcher(req.db);
    const actions = await matcher.findRelevantActions(userId, conflictId, limit);
    
    res.json({
      success: true,
      conflict_id: conflictId,
      actions: actions,
      count: actions.length
    });
  } catch (error) {
    console.error('Error fetching actions:', error);
    res.status(500).json({ error: 'Failed to fetch actions' });
  }
});

// Get actions by type
router.get('/api/actions/type/:type', async (req, res) => {
  const { type } = req.params; // protest, petition, advocacy
  const userId = req.user.id;
  const limit = parseInt(req.query.limit) || 20;
  
  try {
    const matcher = new ActionMatcher(req.db);
    const actions = await matcher.getActionsByType(userId, type, limit);
    
    res.json({
      success: true,
      type: type,
      actions: actions,
      count: actions.length
    });
  } catch (error) {
    console.error('Error fetching actions:', error);
    res.status(500).json({ error: 'Failed to fetch actions' });
  }
});

// Get user's representatives
router.get('/api/actions/representatives', async (req, res) => {
  const userId = req.user.id;
  
  try {
    // Get user location
    const user = await req.db.query(
      'SELECT latitude, longitude FROM users WHERE id = $1',
      [userId]
    );
    
    const { latitude, longitude } = user.rows[0];
    
    // Get representatives
    const congressService = new CongressService(process.env.PROPUBLICA_API_KEY);
    const representatives = await congressService.getRepresentativesByLocation(
      latitude,
      longitude
    );
    
    res.json({
      success: true,
      representatives: representatives
    });
  } catch (error) {
    console.error('Error fetching representatives:', error);
    res.status(500).json({ error: 'Failed to fetch representatives' });
  }
});

// Mark user participation in action
router.post('/api/actions/:actionId/participate', async (req, res) => {
  const { actionId } = req.params;
  const userId = req.user.id;
  const { participation_type, personal_message } = req.body;
  
  try {
    await req.db.query(`
      INSERT INTO user_action_participation
      (user_id, action_id, participation_type, personal_message, status)
      VALUES ($1, $2, $3, $4, 'interested')
      ON CONFLICT (user_id, action_id)
      DO UPDATE SET
        participation_type = $3,
        personal_message = $4,
        status = 'interested'
    `, [userId, actionId, participation_type, personal_message]);
    
    res.json({
      success: true,
      message: 'Participation recorded'
    });
  } catch (error) {
    console.error('Error recording participation:', error);
    res.status(500).json({ error: 'Failed to record participation' });
  }
});

// Mark action as completed
router.post('/api/actions/:actionId/complete', async (req, res) => {
  const { actionId } = req.params;
  const userId = req.user.id;
  
  try {
    await req.db.query(`
      UPDATE user_action_participation
      SET status = 'completed', completed_at = NOW()
      WHERE user_id = $1 AND action_id = $2
    `, [userId, actionId]);
    
    // Award badge/achievement (if applicable)
    await awardActionBadge(userId, actionId);
    
    res.json({
      success: true,
      message: 'Action marked as completed'
    });
  } catch (error) {
    console.error('Error completing action:', error);
    res.status(500).json({ error: 'Failed to complete action' });
  }
});

// Set reminder for action
router.post('/api/actions/:actionId/remind', async (req, res) => {
  const { actionId } = req.params;
  const userId = req.user.id;
  const { reminder_type } = req.body; // 1_day_before, 1_hour_before
  
  try {
    // Get action start time
    const action = await req.db.query(
      'SELECT start_time FROM actions WHERE id = $1',
      [actionId]
    );
    
    if (!action.rows.length) {
      return res.status(404).json({ error: 'Action not found' });
    }
    
    // Calculate reminder time
    const startTime = new Date(action.rows[0].start_time);
    let reminderTime;
    
    if (reminder_type === '1_day_before') {
      reminderTime = new Date(startTime.getTime() - 24 * 60 * 60 * 1000);
    } else if (reminder_type === '1_hour_before') {
      reminderTime = new Date(startTime.getTime() - 60 * 60 * 1000);
    } else {
      return res.status(400).json({ error: 'Invalid reminder type' });
    }
    
    // Create reminder
    await req.db.query(`
      INSERT INTO action_reminders
      (user_id, action_id, reminder_time, reminder_type)
      VALUES ($1, $2, $3, $4)
      ON CONFLICT (user_id, action_id, reminder_type)
      DO UPDATE SET reminder_time = $3
    `, [userId, actionId, reminderTime, reminder_type]);
    
    res.json({
      success: true,
      reminder_time: reminderTime
    });
  } catch (error) {
    console.error('Error setting reminder:', error);
    res.status(500).json({ error: 'Failed to set reminder' });
  }
});

// Report action
router.post('/api/actions/:actionId/report', async (req, res) => {
  const { actionId } = req.params;
  const userId = req.user.id;
  const { report_type, description } = req.body;
  
  try {
    await req.db.query(`
      INSERT INTO action_reports
      (action_id, user_id, report_type, description)
      VALUES ($1, $2, $3, $4)
    `, [actionId, userId, report_type, description]);
    
    res.json({
      success: true,
      message: 'Report submitted'
    });
  } catch (error) {
    console.error('Error submitting report:', error);
    res.status(500).json({ error: 'Failed to submit report' });
  }
});

module.exports = router;
```

---

## 9. Mobile UI Components (React Native)

```javascript
// screens/ActionsScreen.js
import React, { useState, useEffect } from 'react';
import { View, ScrollView, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Card, Chip, Button, FAB } from 'react-native-paper';
import MapView, { Marker } from 'react-native-maps';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

export default function ActionsScreen({ route, navigation }) {
  const { conflictId } = route.params;
  const [actions, setActions] = useState([]);
  const [selectedType, setSelectedType] = useState('all');
  const [viewMode, setViewMode] = useState('list'); // list or map

  useEffect(() => {
    fetchActions();
  }, [conflictId, selectedType]);

  const fetchActions = async () => {
    const endpoint = selectedType === 'all'
      ? `/api/actions/conflict/${conflictId}`
      : `/api/actions/type/${selectedType}`;
    
    const response = await fetch(endpoint);
    const data = await response.json();
    setActions(data.actions);
  };

  const getIconForType = (type) => {
    const icons = {
      protest: 'bullhorn',
      petition: 'file-sign',
      advocacy: 'phone',
      community_gathering: 'account-group'
    };
    return icons[type] || 'information';
  };

  const getColorForType = (type) => {
    const colors = {
      protest: '#E74C3C',
      petition: '#3498DB',
      advocacy: '#9B59B6',
      community_gathering: '#1ABC9C'
    };
    return colors[type] || '#95A5A6';
  };

  return (
    <View style={styles.container}>
      {/* Type Filter */}
      <ScrollView horizontal style={styles.filterRow} showsHorizontalScrollIndicator={false}>
        <Chip
          selected={selectedType === 'all'}
          onPress={() => setSelectedType('all')}
          style={styles.chip}
        >
          All Actions
        </Chip>
        <Chip
          selected={selectedType === 'protest'}
          onPress={() => setSelectedType('protest')}
          style={styles.chip}
          icon="bullhorn"
        >
          Protests
        </Chip>
        <Chip
          selected={selectedType === 'petition'}
          onPress={() => setSelectedType('petition')}
          style={styles.chip}
          icon="file-sign"
        >
          Petitions
        </Chip>
        <Chip
          selected={selectedType === 'advocacy'}
          onPress={() => setSelectedType('advocacy')}
          style={styles.chip}
          icon="phone"
        >
          Advocacy
        </Chip>
      </ScrollView>

      {/* View Toggle */}
      <View style={styles.viewToggle}>
        <TouchableOpacity
          style={[styles.toggleButton, viewMode === 'list' && styles.activeToggle]}
          onPress={() => setViewMode('list')}
        >
          <Icon name="view-list" size={24} color={viewMode === 'list' ? '#FFF' : '#666'} />
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.toggleButton, viewMode === 'map' && styles.activeToggle]}
          onPress={() => setViewMode('map')}
        >
          <Icon name="map" size={24} color={viewMode === 'map' ? '#FFF' : '#666'} />
        </TouchableOpacity>
      </View>

      {/* Content */}
      {viewMode === 'list' ? (
        <ScrollView style={styles.actionsList}>
          {actions.map(action => (
            <ActionCard
              key={action.id}
              action={action}
              onPress={() => navigation.navigate('ActionDetail', { actionId: action.id })}
              icon={getIconForType(action.type)}
              color={getColorForType(action.type)}
            />
          ))}
        </ScrollView>
      ) : (
        <MapView
          style={styles.map}
          initialRegion={{
            latitude: actions[0]?.latitude || 37.78825,
            longitude: actions[0]?.longitude || -122.4324,
            latitudeDelta: 0.5,
            longitudeDelta: 0.5,
          }}
        >
          {actions.filter(a => a.latitude && a.longitude).map(action => (
            <Marker
              key={action.id}
              coordinate={{
                latitude: action.latitude,
                longitude: action.longitude
              }}
              title={action.title}
              description={action.short_description}
              pinColor={getColorForType(action.type)}
              onCalloutPress={() => navigation.navigate('ActionDetail', { actionId: action.id })}
            />
          ))}
        </MapView>
      )}
    </View>
  );
}

function ActionCard({ action, onPress, icon, color }) {
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  };

  return (
    <Card style={styles.card} onPress={onPress}>
      <Card.Content>
        <View style={styles.cardHeader}>
          <View style={[styles.iconBadge, { backgroundColor: color }]}>
            <Icon name={icon} size={24} color="#FFF" />
          </View>
          <View style={styles.cardTitleContainer}>
            <Text style={styles.cardTitle} numberOfLines={2}>
              {action.title}
            </Text>
            <Text style={styles.cardSubtitle}>
              {action.type.replace('_', ' ')}
            </Text>
          </View>
        </View>

        {action.short_description && (
          <Text style={styles.cardDescription} numberOfLines={2}>
            {action.short_description}
          </Text>
        )}

        <View style={styles.cardMeta}>
          {action.start_time && (
            <View style={styles.metaItem}>
              <Icon name="calendar" size={16} color="#666" />
              <Text style={styles.metaText}>{formatDate(action.start_time)}</Text>
            </View>
          )}
          
          {action.location_name && (
            <View style={styles.metaItem}>
              <Icon name="map-marker" size={16} color="#666" />
              <Text style={styles.metaText} numberOfLines={1}>
                {action.location_name}
              </Text>
            </View>
          )}

          {action.distance_km && (
            <View style={styles.metaItem}>
              <Icon name="walk" size={16} color="#666" />
              <Text style={styles.metaText}>
                {action.distance_km.toFixed(1)} km away
              </Text>
            </View>
          )}

          {action.signature_count && (
            <View style={styles.metaItem}>
              <Icon name="pen" size={16} color="#666" />
              <Text style={styles.metaText}>
                {action.signature_count.toLocaleString()} signatures
              </Text>
            </View>
          )}
        </View>

        <View style={styles.relevanceBar}>
          <View 
            style={[
              styles.relevanceIndicator,
              { width: `${action.relevance_score * 100}%`, backgroundColor: color }
            ]}
          />
        </View>
        <Text style={styles.relevanceText}>
          {Math.round(action.relevance_score * 100)}% match for you
        </Text>
      </Card.Content>
    </Card>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  filterRow: {
    padding: 10,
    backgroundColor: '#FFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  chip: {
    marginRight: 8,
  },
  viewToggle: {
    flexDirection: 'row',
    padding: 10,
    backgroundColor: '#FFF',
    justifyContent: 'center',
  },
  toggleButton: {
    padding: 10,
    marginHorizontal: 5,
    borderRadius: 8,
    backgroundColor: '#F0F0F0',
  },
  activeToggle: {
    backgroundColor: '#2196F3',
  },
  actionsList: {
    flex: 1,
    padding: 10,
  },
  map: {
    flex: 1,
  },
  card: {
    marginBottom: 12,
    elevation: 2,
  },
  cardHeader: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  iconBadge: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  cardTitleContainer: {
    flex: 1,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  cardSubtitle: {
    fontSize: 12,
    color: '#666',
    textTransform: 'capitalize',
  },
  cardDescription: {
    fontSize: 14,
    color: '#444',
    marginBottom: 12,
  },
  cardMeta: {
    flexDirection: 'column',
    gap: 6,
  },
  metaItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  metaText: {
    fontSize: 13,
    color: '#666',
    marginLeft: 6,
    flex: 1,
  },
  relevanceBar: {
    height: 4,
    backgroundColor: '#E0E0E0',
    borderRadius: 2,
    marginTop: 12,
    overflow: 'hidden',
  },
  relevanceIndicator: {
    height: '100%',
    borderRadius: 2,
  },
  relevanceText: {
    fontSize: 11,
    color: '#999',
    marginTop: 4,
    textAlign: 'right',
  },
});
```

### Action Detail Screen

```javascript
// screens/ActionDetailScreen.js
import React, { useState, useEffect } from 'react';
import { View, ScrollView, StyleSheet, Linking, Alert } from 'react-native';
import { Text, Button, Chip, Card, Divider } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import MapView, { Marker } from 'react-native-maps';

export default function ActionDetailScreen({ route, navigation }) {
  const { actionId } = route.params;
  const [action, setAction] = useState(null);
  const [participated, setParticipated] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchActionDetails();
  }, [actionId]);

  const fetchActionDetails = async () => {
    try {
      const response = await fetch(`/api/actions/${actionId}`);
      const data = await response.json();
      setAction(data.action);
      setParticipated(data.user_participated);
    } catch (error) {
      console.error('Error fetching action:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleParticipate = async () => {
    try {
      await fetch(`/api/actions/${actionId}/participate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          participation_type: action.type === 'petition' ? 'signed' : 'interested'
        })
      });
      
      setParticipated(true);
      
      // Open external link
      if (action.url) {
        Linking.openURL(action.url);
      }
      
      Alert.alert('Success', 'Your participation has been recorded!');
    } catch (error) {
      Alert.alert('Error', 'Failed to record participation');
    }
  };

  const handleSetReminder = async (reminderType) => {
    try {
      await fetch(`/api/actions/${actionId}/remind`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ reminder_type: reminderType })
      });
      
      Alert.alert('Reminder Set', 'We\'ll remind you before the event');
    } catch (error) {
      Alert.alert('Error', 'Failed to set reminder');
    }
  };

  const handleShare = async () => {
    // Share functionality
    const shareMessage = `Check out this action: ${action.title}\n${action.url}`;
    // Implement share (react-native-share or native Share API)
  };

  if (loading || !action) {
    return <View style={styles.loading}><Text>Loading...</Text></View>;
  }

  return (
    <ScrollView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.title}>{action.title}</Text>
        <View style={styles.typeChip}>
          <Chip icon={getIconForType(action.type)} mode="flat">
            {action.type.replace('_', ' ')}
          </Chip>
        </View>
      </View>

      {/* AI-Enhanced Description */}
      {action.enhanced_description && (
        <Card style={styles.card}>
          <Card.Content>
            <Text style={styles.sectionTitle}>Why This Matters</Text>
            <Text style={styles.description}>
              {action.enhanced_description.short_description ||
               action.enhanced_description.why_attend ||
               action.enhanced_description.why_sign}
            </Text>
          </Card.Content>
        </Card>
      )}

      {/* Event Details (for protests) */}
      {action.type === 'protest' && (
        <>
          <Card style={styles.card}>
            <Card.Content>
              <Text style={styles.sectionTitle}>Event Details</Text>
              
              <DetailRow
                icon="calendar"
                label="When"
                value={formatDateTime(action.start_time)}
              />
              
              <DetailRow
                icon="map-marker"
                label="Where"
                value={action.location_name || action.address}
              />
              
              {action.organizer_name && (
                <DetailRow
                  icon="account"
                  label="Organizer"
                  value={action.organizer_name}
                />
              )}
              
              {action.is_free && (
                <DetailRow
                  icon="ticket"
                  label="Cost"
                  value="Free"
                />
              )}
            </Card.Content>
          </Card>

          {/* Map */}
          {action.latitude && action.longitude && (
            <View style={styles.mapContainer}>
              <MapView
                style={styles.map}
                initialRegion={{
                  latitude: action.latitude,
                  longitude: action.longitude,
                  latitudeDelta: 0.01,
                  longitudeDelta: 0.01,
                }}
              >
                <Marker
                  coordinate={{
                    latitude: action.latitude,
                    longitude: action.longitude
                  }}
                  title={action.title}
                />
              </MapView>
            </View>
          )}

          {/* What to Expect */}
          {action.enhanced_description?.what_to_expect && (
            <Card style={styles.card}>
              <Card.Content>
                <Text style={styles.sectionTitle}>What to Expect</Text>
                <Text style={styles.bodyText}>
                  {action.enhanced_description.what_to_expect}
                </Text>
              </Card.Content>
            </Card>
          )}

          {/* What to Bring */}
          {action.enhanced_description?.what_to_bring && (
            <Card style={styles.card}>
              <Card.Content>
                <Text style={styles.sectionTitle}>What to Bring</Text>
                {action.enhanced_description.what_to_bring.map((item, i) => (
                  <View key={i} style={styles.listItem}>
                    <Icon name="check-circle" size={20} color="#4CAF50" />
                    <Text style={styles.listItemText}>{item}</Text>
                  </View>
                ))}
              </Card.Content>
            </Card>
          )}
        </>
      )}

      {/* Petition Details */}
      {action.type === 'petition' && (
        <>
          <Card style={styles.card}>
            <Card.Content>
              <Text style={styles.sectionTitle}>Petition Progress</Text>
              
              <View style={styles.progressContainer}>
                <View style={styles.progressBar}>
                  <View 
                    style={[
                      styles.progressFill,
                      { width: `${(action.signature_count / action.signature_goal) * 100}%` }
                    ]}
                  />
                </View>
                <Text style={styles.progressText}>
                  {action.signature_count.toLocaleString()} of {action.signature_goal.toLocaleString()} signatures
                </Text>
              </View>

              {action.target && (
                <DetailRow
                  icon="bullhorn"
                  label="Petition Target"
                  value={action.target}
                />
              )}
            </Card.Content>
          </Card>

          {/* Why Sign */}
          {action.enhanced_description?.why_sign && (
            <Card style={styles.card}>
              <Card.Content>
                <Text style={styles.sectionTitle}>Why Sign This Petition</Text>
                <Text style={styles.bodyText}>
                  {action.enhanced_description.why_sign}
                </Text>
              </Card.Content>
            </Card>
          )}

          {/* Impact */}
          {action.enhanced_description?.impact && (
            <Card style={styles.card}>
              <Card.Content>
                <Text style={styles.sectionTitle}>Expected Impact</Text>
                <Text style={styles.bodyText}>
                  {action.enhanced_description.impact}
                </Text>
              </Card.Content>
            </Card>
          )}
        </>
      )}

      {/* Advocacy Details */}
      {action.type === 'advocacy' && (
        <>
          <Card style={styles.card}>
            <Card.Content>
              <Text style={styles.sectionTitle}>Contact Your Representatives</Text>
              <Text style={styles.bodyText}>
                Make your voice heard by contacting your elected officials about this issue.
              </Text>
            </Card.Content>
          </Card>

          {action.representatives && action.representatives.length > 0 && (
            <Card style={styles.card}>
              <Card.Content>
                <Text style={styles.sectionTitle}>Your Representatives</Text>
                {action.representatives.map((rep, i) => (
                  <RepresentativeCard key={i} representative={rep} />
                ))}
              </Card.Content>
            </Card>
          )}

          {/* Talking Points */}
          {action.talking_points && (
            <Card style={styles.card}>
              <Card.Content>
                <Text style={styles.sectionTitle}>Key Points to Mention</Text>
                {action.talking_points.map((point, i) => (
                  <View key={i} style={styles.listItem}>
                    <Icon name="message-text" size={20} color="#2196F3" />
                    <Text style={styles.listItemText}>{point}</Text>
                  </View>
                ))}
              </Card.Content>
            </Card>
          )}
        </>
      )}

      {/* How It Helps */}
      {action.enhanced_description?.how_it_helps && (
        <Card style={styles.card}>
          <Card.Content>
            <Text style={styles.sectionTitle}>How This Helps</Text>
            <Text style={styles.bodyText}>
              {action.enhanced_description.how_it_helps}
            </Text>
          </Card.Content>
        </Card>
      )}

      {/* Action Buttons */}
      <View style={styles.actionButtons}>
        <Button
          mode="contained"
          onPress={handleParticipate}
          style={styles.primaryButton}
          disabled={participated}
          icon={participated ? "check" : getIconForType(action.type)}
        >
          {participated ? 'Participating' : getActionButtonText(action.type)}
        </Button>

        {action.type === 'protest' && !participated && (
          <View style={styles.secondaryButtons}>
            <Button
              mode="outlined"
              onPress={() => handleSetReminder('1_day_before')}
              style={styles.secondaryButton}
              icon="bell"
            >
              Remind Me
            </Button>
            <Button
              mode="outlined"
              onPress={handleShare}
              style={styles.secondaryButton}
              icon="share"
            >
              Share
            </Button>
          </View>
        )}
      </View>

      {/* Organizer Info */}
      {action.organizer_name && (
        <Card style={styles.card}>
          <Card.Content>
            <Text style={styles.sectionTitle}>Organized By</Text>
            <Text style={styles.bodyText}>{action.organizer_name}</Text>
            {action.organizer_description && (
              <Text style={styles.smallText}>{action.organizer_description}</Text>
            )}
          </Card.Content>
        </Card>
      )}
    </ScrollView>
  );
}

function DetailRow({ icon, label, value }) {
  return (
    <View style={styles.detailRow}>
      <Icon name={icon} size={20} color="#666" />
      <View style={styles.detailContent}>
        <Text style={styles.detailLabel}>{label}</Text>
        <Text style={styles.detailValue}>{value}</Text>
      </View>
    </View>
  );
}

function RepresentativeCard({ representative }) {
  const handleContact = (method) => {
    if (method === 'phone') {
      Linking.openURL(`tel:${representative.phone}`);
    } else if (method === 'web') {
      Linking.openURL(representative.contact_form);
    }
  };

  return (
    <View style={styles.repCard}>
      <Text style={styles.repName}>{representative.name}</Text>
      <Text style={styles.repTitle}>
        {representative.chamber === 'house' ? 'Representative' : 'Senator'} ({representative.party})
      </Text>
      <View style={styles.repActions}>
        {representative.phone && (
          <Button
            mode="outlined"
            onPress={() => handleContact('phone')}
            icon="phone"
            compact
          >
            Call
          </Button>
        )}
        {representative.contact_form && (
          <Button
            mode="outlined"
            onPress={() => handleContact('web')}
            icon="web"
            compact
          >
            Email
          </Button>
        )}
      </View>
    </View>
  );
}

function getIconForType(type) {
  const icons = {
    protest: 'bullhorn',
    petition: 'file-sign',
    advocacy: 'phone'
  };
  return icons[type] || 'information';
}

function getActionButtonText(type) {
  const texts = {
    protest: 'I\'m Going',
    petition: 'Sign Petition',
    advocacy: 'Take Action'
  };
  return texts[type] || 'Participate';
}

function formatDateTime(isoString) {
  const date = new Date(isoString);
  return date.toLocaleDateString('en-US', {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit'
  });
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loading: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    padding: 20,
    backgroundColor: '#FFF',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  typeChip: {
    alignSelf: 'flex-start',
  },
  card: {
    margin: 12,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  description: {
    fontSize: 15,
    lineHeight: 22,
    color: '#333',
  },
  bodyText: {
    fontSize: 14,
    lineHeight: 20,
    color: '#444',
  },
  smallText: {
    fontSize: 12,
    color: '#666',
    marginTop: 8,
  },
  detailRow: {
    flexDirection: 'row',
    marginBottom: 16,
  },
  detailContent: {
    marginLeft: 12,
    flex: 1,
  },
  detailLabel: {
    fontSize: 12,
    color: '#666',
    marginBottom: 4,
  },
  detailValue: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },
  mapContainer: {
    height: 200,
    marginHorizontal: 12,
    marginVertical: 12,
    borderRadius: 8,
    overflow: 'hidden',
  },
  map: {
    flex: 1,
  },
  listItem: {
    flexDirection: 'row',
    marginBottom: 12,
    alignItems: 'flex-start',
  },
  listItemText: {
    fontSize: 14,
    color: '#444',
    marginLeft: 12,
    flex: 1,
  },
  progressContainer: {
    marginBottom: 16,
  },
  progressBar: {
    height: 8,
    backgroundColor: '#E0E0E0',
    borderRadius: 4,
    overflow: 'hidden',
    marginBottom: 8,
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#4CAF50',
  },
  progressText: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
  },
  repCard: {
    padding: 12,
    backgroundColor: '#F9F9F9',
    borderRadius: 8,
    marginBottom: 12,
  },
  repName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  repTitle: {
    fontSize: 13,
    color: '#666',
    marginBottom: 12,
  },
  repActions: {
    flexDirection: 'row',
    gap: 8,
  },
  actionButtons: {
    padding: 16,
  },
  primaryButton: {
    marginBottom: 12,
    paddingVertical: 6,
  },
  secondaryButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  secondaryButton: {
    flex: 1,
    marginHorizontal: 4,
  },
});
```

---

## 10. Notification System for Reminders

```javascript
// services/reminder_service.js
const admin = require('firebase-admin');

class ReminderService {
  /**
   * Send push notifications for action reminders
   */
  
  constructor(db) {
    this.db = db;
  }

  async sendDueReminders() {
    /**
     * Check for reminders that need to be sent
     * Run this every 15 minutes via cron job
     */
    
    const reminders = await this.db.query(`
      SELECT 
        r.id,
        r.user_id,
        r.action_id,
        r.reminder_type,
        u.fcm_token,
        a.title,
        a.type,
        a.start_time,
        a.location_name
      FROM action_reminders r
      JOIN users u ON r.user_id = u.id
      JOIN actions a ON r.action_id = a.id
      WHERE 
        r.reminder_time <= NOW()
        AND r.sent = false
        AND u.fcm_token IS NOT NULL
    `);

    for (const reminder of reminders.rows) {
      await this.sendReminder(reminder);
    }

    console.log(`Sent ${reminders.rows.length} reminders`);
  }

  async sendReminder(reminder) {
    /**
     * Send individual reminder notification
     */
    
    const message = {
      notification: {
        title: this.getReminderTitle(reminder),
        body: this.getReminderBody(reminder)
      },
      data: {
        type: 'action_reminder',
        action_id: reminder.action_id,
        action_type: reminder.type
      },
      token: reminder.fcm_token
    };

    try {
      await admin.messaging().send(message);
      
      // Mark as sent
      await this.db.query(
        'UPDATE action_reminders SET sent = true WHERE id = $1',
        [reminder.id]
      );

      console.log(`âœ“ Sent reminder to user ${reminder.user_id}`);
    } catch (error) {
      console.error('Error sending reminder:', error);
    }
  }

  getReminderTitle(reminder) {
    if (reminder.reminder_type === '1_hour_before') {
      return 'ðŸ”” Event starting in 1 hour!';
    } else {
      return 'ðŸ“… Reminder: Action tomorrow';
    }
  }

  getReminderBody(reminder) {
    const actionType = reminder.type === 'protest' ? 'event' : reminder.type;
    return `${reminder.title} at ${reminder.location_name}`;
  }
}

module.exports = ReminderService;
```

---

## 11. Scheduling (Cron Jobs)

```javascript
// jobs/scheduled_tasks.js
const cron = require('node-cron');
const ActionDiscoveryPipeline = require('../pipeline/action_discovery_pipeline');
const ReminderService = require('../services/reminder_service');

class ScheduledTasks {
  constructor(db) {
    this.db = db;
    this.discoveryPipeline = new ActionDiscoveryPipeline(db);
    this.reminderService = new ReminderService(db);
  }

  start() {
    // Run action discovery every 6 hours
    cron.schedule('0 */6 * * *', async () => {
      console.log('ðŸ” Running action discovery pipeline...');
      await this.discoveryPipeline.runDiscovery();
    });

    // Send reminders every 15 minutes
    cron.schedule('*/15 * * * *', async () => {
      console.log('ðŸ”” Checking for due reminders...');
      await this.reminderService.sendDueReminders();
    });

    // Clean up old/completed actions daily at 2 AM
    cron.schedule('0 2 * * *', async () => {
      console.log('ðŸ§¹ Cleaning up old actions...');
      await this.cleanupOldActions();
    });

    console.log('âœ… Scheduled tasks started');
  }

  async cleanupOldActions() {
    /**
     * Archive completed actions older than 30 days
     */
    
    await this.db.query(`
      UPDATE actions
      SET status = 'archived'
      WHERE 
        end_time < NOW() - INTERVAL '30 days'
        AND status = 'active'
    `);
  }
}

module.exports = ScheduledTasks;
```

---

## 12. Best Practices Summary

### Security
- âœ… Validate all external API data
- âœ… Sanitize user-generated content (reports, messages)
- âœ… Rate limit API endpoints
- âœ… Verify action authenticity before displaying
- âœ… Protect user location data

### Privacy
- âœ… Only store necessary location data (city-level for matching)
- âœ… Allow users to opt-out of location-based features
- âœ… Don't share participation data publicly without consent
- âœ… Anonymize aggregate statistics

### User Experience
- âœ… Show actions most relevant to user first
- âœ… Clear call-to-action buttons
- âœ… Easy one-tap participation
- âœ… Provide context (why it matters)
- âœ… Set realistic expectations

### Content Quality
- âœ… AI-enhance descriptions for clarity
- âœ… Verify organizers when possible
- âœ… Flag suspicious/spam content
- âœ… Allow user reports
- âœ… Admin review for high-risk actions

---

## 13. Implementation Roadmap

### Phase 1: Foundation (Weeks 1-2)
- [ ] Set up database schema
- [ ] Integrate Eventbrite + Meetup APIs
- [ ] Build basic action matcher
- [ ] Create mobile UI screens
- [ ] Test with 5-10 sample actions

### Phase 2: Enhanced Discovery (Weeks 3-4)
- [ ] Add Change.org integration
- [ ] Build grassroots scraper
- [ ] Implement AI enhancement
- [ ] Add geolocation matching
- [ ] Create admin review queue

### Phase 3: Advocacy (Weeks 5-6)
- [ ] Integrate ProPublica Congress API
- [ ] Build representative lookup
- [ ] Generate advocacy templates
- [ ] Add Resistbot integration
- [ ] Test with real campaigns

### Phase 4: Engagement (Weeks 7-8)
- [ ] Implement reminder system
- [ ] Add participation tracking
- [ ] Build notification system
- [ ] Create sharing features
- [ ] Add achievement badges

### Phase 5: Optimization (Weeks 9-10)
- [ ] Improve relevance algorithm
- [ ] Add caching layer
- [ ] Optimize geospatial queries
- [ ] A/B test UI variations
- [ ] Performance tuning

---

Would you like me to:
1. **Build the advocacy template generator** with specific examples?
2. **Design the admin moderation dashboard** for reviewing flagged actions?
3. **Create the achievement/badge system** for action participation?
4. **Develop the analytics dashboard** to track action engagement?
5. **Write integration tests** for the action discovery pipeline?# Additional Actions System - Protests, Petitions & Advocacy

## 1. System Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USER LOCATION & PREFERENCES               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ACTION DISCOVERY & AGGREGATION                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Protests    â”‚  â”‚  Petitions   â”‚  â”‚  Advocacy       â”‚  â”‚
â”‚  â”‚  (Events)    â”‚  â”‚  (Change.org)â”‚  â”‚  (Call/Write)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           FILTERING & RELEVANCE MATCHING                     â”‚
â”‚  â€¢ Geographic proximity  â€¢ Conflict relevance                â”‚
â”‚  â€¢ User causes          â€¢ Timing/availability                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              AI-ENHANCED CONTENT GENERATION                  â”‚
â”‚  â€¢ Action descriptions  â€¢ Impact explanations                â”‚
â”‚  â€¢ Participation guides â€¢ Template generation                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   USER INTERFACE                             â”‚
â”‚  â€¢ Action feed         â€¢ Reminders                           â”‚
â”‚  â€¢ One-tap actions     â€¢ Tracking                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Technology Stack

### 2.1 Core Technologies

```yaml
Backend:
  API Framework: Node.js with Express (or Python FastAPI)
  Database: PostgreSQL + PostGIS (for geospatial queries)
  Cache: Redis (for location-based queries)
  Task Queue: Celery or Bull (for scheduled scraping)
  Geolocation: Google Maps API / Mapbox

Data Sources:
  Events: Eventbrite API, Meetup API, Facebook Events Graph API
  Petitions: Change.org API, Action Network API
  Advocacy: Resistbot integration, Phone2Action API
  News: Google News API, Twitter API (for grassroots events)

Mobile App:
  Framework: React Native
  Maps: React Native Maps (Google Maps or Mapbox)
  Notifications: Firebase Cloud Messaging
  Deep Linking: React Navigation

Scraping & Automation:
  Web Scraping: Puppeteer or Playwright (JavaScript-heavy sites)
  API Integration: Axios / Fetch
  Scheduling: Node-cron or Airflow
  Rate Limiting: Bottleneck library

AI Enhancement:
  LLM: Claude API (content generation)
  NLP: spaCy (entity extraction, relevance matching)
  Embeddings: OpenAI Embeddings (semantic search)
```

---

## 3. Data Sources & Integration

### 3.1 Protest/Event Discovery

#### Eventbrite API

```javascript
// services/eventbrite_service.js
const axios = require('axios');

class EventbriteService {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://www.eventbriteapi.com/v3';
  }

  async searchEvents(params) {
    /**
     * Search for protest/advocacy events
     * params: {
     *   location: { lat, lon, radius },
     *   keywords: ['humanitarian', 'refugee', 'protest'],
     *   start_date: ISO string
     * }
     */
    
    const searchParams = {
      'location.latitude': params.location.lat,
      'location.longitude': params.location.lon,
      'location.within': params.location.radius || '50km',
      'start_date.range_start': params.start_date,
      'start_date.range_end': params.end_date,
      'q': params.keywords.join(' OR '),
      'categories': '111,116', // Causes, Community
      'expand': 'venue,organizer'
    };

    try {
      const response = await axios.get(`${this.baseUrl}/events/search/`, {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`
        },
        params: searchParams
      });

      return response.data.events.map(event => this.transformEvent(event));
    } catch (error) {
      console.error('Eventbrite API error:', error);
      return [];
    }
  }

  transformEvent(event) {
    return {
      id: event.id,
      source: 'eventbrite',
      type: 'protest',
      title: event.name.text,
      description: event.description.text,
      start_time: event.start.utc,
      end_time: event.end.utc,
      timezone: event.start.timezone,
      location: {
        name: event.venue?.name,
        address: event.venue?.address?.localized_address_display,
        latitude: event.venue?.latitude,
        longitude: event.venue?.longitude
      },
      organizer: {
        name: event.organizer?.name,
        description: event.organizer?.description?.text
      },
      url: event.url,
      is_free: event.is_free,
      capacity: event.capacity,
      scraped_at: new Date().toISOString()
    };
  }
}

module.exports = EventbriteService;
```

#### Meetup API

```javascript
// services/meetup_service.js
const axios = require('axios');

class MeetupService {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.meetup.com';
  }

  async searchEvents(params) {
    /**
     * Search Meetup for advocacy events
     */
    
    const searchParams = {
      lat: params.location.lat,
      lon: params.location.lon,
      radius: params.location.radius || 50,
      text: params.keywords.join(' '),
      category: '27,29', // Socializing, Causes
      upcoming_events: true
    };

    try {
      const response = await axios.get(`${this.baseUrl}/find/events`, {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`
        },
        params: searchParams
      });

      return response.data.events.map(event => this.transformEvent(event));
    } catch (error) {
      console.error('Meetup API error:', error);
      return [];
    }
  }

  transformEvent(event) {
    return {
      id: event.id,
      source: 'meetup',
      type: 'community_gathering',
      title: event.name,
      description: event.description,
      start_time: new Date(event.time).toISOString(),
      duration: event.duration,
      location: {
        name: event.venue?.name,
        address: event.venue?.address_1,
        city: event.venue?.city,
        latitude: event.venue?.lat,
        longitude: event.venue?.lon
      },
      group: {
        name: event.group.name,
        url: event.group.urlname
      },
      url: event.link,
      attendance: event.yes_rsvp_count,
      scraped_at: new Date().toISOString()
    };
  }
}

module.exports = MeetupService;
```

#### Custom Web Scraper for Grassroots Events

```javascript
// scrapers/grassroots_scraper.js
const puppeteer = require('puppeteer');
const cheerio = require('cheerio');

class GrassrootsEventScraper {
  /**
   * Scrape grassroots activist websites and community boards
   */
  
  constructor() {
    this.sources = [
      'https://www.protestnyc.com',
      'https://www.mobilize.us',
      // Add activist organization websites
    ];
  }

  async scrapeAll() {
    const browser = await puppeteer.launch({ headless: true });
    const events = [];

    for (const source of this.sources) {
      try {
        const sourceEvents = await this.scrapeSource(browser, source);
        events.push(...sourceEvents);
      } catch (error) {
        console.error(`Error scraping ${source}:`, error);
      }
    }

    await browser.close();
    return events;
  }

  async scrapeSource(browser, url) {
    const page = await browser.newPage();
    await page.goto(url, { waitUntil: 'networkidle2' });
    
    const html = await page.content();
    const $ = cheerio.load(html);
    
    // Parse events (structure depends on site)
    const events = [];
    
    $('.event-item').each((i, elem) => {
      const event = {
        id: $(elem).attr('data-id') || `scraped_${Date.now()}_${i}`,
        source: 'grassroots',
        type: 'protest',
        title: $(elem).find('.event-title').text().trim(),
        description: $(elem).find('.event-description').text().trim(),
        start_time: $(elem).find('.event-time').attr('datetime'),
        location: {
          address: $(elem).find('.event-location').text().trim()
        },
        url: $(elem).find('a').attr('href'),
        scraped_at: new Date().toISOString()
      };
      
      events.push(event);
    });
    
    await page.close();
    return events;
  }

  async geocodeAddress(address) {
    /**
     * Convert address to lat/lon using Google Geocoding API
     */
    const geocodeUrl = `https://maps.googleapis.com/maps/api/geocode/json`;
    
    const response = await axios.get(geocodeUrl, {
      params: {
        address: address,
        key: process.env.GOOGLE_MAPS_API_KEY
      }
    });
    
    if (response.data.results.length > 0) {
      const location = response.data.results[0].geometry.location;
      return {
        latitude: location.lat,
        longitude: location.lng
      };
    }
    
    return null;
  }
}

module.exports = GrassrootsEventScraper;
```

### 3.2 Petition Integration

#### Change.org API

```javascript
// services/change_org_service.js
const axios = require('axios');

class ChangeOrgService {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.change.org/v1';
  }

  async searchPetitions(keywords, country) {
    /**
     * Search for relevant petitions
     */
    
    try {
      const response = await axios.get(`${this.baseUrl}/petitions/search`, {
        params: {
          q: keywords.join(' '),
          country_code: country,
          sort: 'recent',
          api_key: this.apiKey
        }
      });

      return response.data.petitions.map(petition => 
        this.transformPetition(petition)
      );
    } catch (error) {
      console.error('Change.org API error:', error);
      return [];
    }
  }

  async getPetitionDetails(petitionId) {
    /**
     * Get detailed information about a petition
     */
    
    try {
      const response = await axios.get(
        `${this.baseUrl}/petitions/${petitionId}`,
        {
          params: { api_key: this.apiKey }
        }
      );

      return this.transformPetition(response.data);
    } catch (error) {
      console.error('Change.org petition fetch error:', error);
      return null;
    }
  }

  transformPetition(petition) {
    return {
      id: petition.id,
      source: 'change_org',
      type: 'petition',
      title: petition.title,
      description: petition.overview,
      target: petition.targets?.[0]?.name || 'Decision makers',
      creator: petition.creator_name,
      signature_count: petition.signature_count,
      goal: petition.signature_goal,
      status: petition.status,
      url: petition.url,
      created_at: petition.created_at,
      tags: petition.tags || [],
      scraped_at: new Date().toISOString()
    };
  }
}

module.exports = ChangeOrgService;
```

#### Action Network API (for NGO-hosted petitions)

```javascript
// services/action_network_service.js
const axios = require('axios');

class ActionNetworkService {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://actionnetwork.org/api/v2';
  }

  async getPetitions() {
    /**
     * Get petitions from Action Network
     */
    
    try {
      const response = await axios.get(`${this.baseUrl}/petitions`, {
        headers: {
          'OSDI-API-Token': this.apiKey
        }
      });

      return response.data._embedded['osdi:petitions'].map(petition => 
        this.transformPetition(petition)
      );
    } catch (error) {
      console.error('Action Network API error:', error);
      return [];
    }
  }

  transformPetition(petition) {
    return {
      id: petition.identifiers?.[0],
      source: 'action_network',
      type: 'petition',
      title: petition.title,
      description: petition.description,
      target: petition.target,
      creator: petition.creator?.name,
      signature_count: petition.total_signatures || 0,
      url: petition.browser_url,
      created_at: petition.created_date,
      tags: petition.tags || [],
      scraped_at: new Date().toISOString()
    };
  }
}

module.exports = ActionNetworkService;
```

### 3.3 Advocacy Actions (Call/Write Representatives)

#### Congressional Contact Information

```javascript
// services/congress_service.js
const axios = require('axios');

class CongressService {
  /**
   * Use ProPublica Congress API to get representative info
   * https://projects.propublica.org/api-docs/congress-api/
   */
  
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.propublica.org/congress/v1';
  }

  async getRepresentativesByLocation(latitude, longitude) {
    /**
     * Find representatives for a specific location
     */
    
    // First, get district from coordinates
    const district = await this.getDistrictFromCoordinates(latitude, longitude);
    
    if (!district) return [];

    try {
      // Get House member for district
      const houseResponse = await axios.get(
        `${this.baseUrl}/members/house/${district.state}/${district.district}/current.json`,
        {
          headers: { 'X-API-Key': this.apiKey }
        }
      );

      // Get Senators for state
      const senateResponse = await axios.get(
        `${this.baseUrl}/members/senate/${district.state}/current.json`,
        {
          headers: { 'X-API-Key': this.apiKey }
        }
      );

      const representatives = [
        ...houseResponse.data.results,
        ...senateResponse.data.results
      ];

      return representatives.map(rep => this.transformRepresentative(rep));
    } catch (error) {
      console.error('Congress API error:', error);
      return [];
    }
  }

  async getDistrictFromCoordinates(latitude, longitude) {
    /**
     * Use Google Civic Information API to get congressional district
     */
    
    const civicUrl = 'https://www.googleapis.com/civicinfo/v2/representatives';
    
    try {
      const response = await axios.get(civicUrl, {
        params: {
          key: process.env.GOOGLE_CIVIC_API_KEY,
          address: `${latitude},${longitude}`,
          levels: 'country',
          roles: 'legislatorLowerBody,legislatorUpperBody'
        }
      });

      // Extract district info from response
      const divisions = response.data.divisions;
      
      // Parse congressional district
      // Format: "ocd-division/country:us/state:ca/cd:12"
      const cdDivision = Object.keys(divisions).find(key => 
        key.includes('/cd:')
      );

      if (cdDivision) {
        const parts = cdDivision.split('/');
        const state = parts.find(p => p.startsWith('state:')).split(':')[1];
        const district = parts.find(p => p.startsWith('cd:')).split(':')[1];
        
        return {
          state: state.toUpperCase(),
          district: parseInt(district)
        };
      }
    } catch (error) {
      console.error('Civic API error:', error);
    }
    
    return null;
  }

  transformRepresentative(rep) {
    return {
      id: rep.id,
      name: `${rep.first_name} ${rep.last_name}`,
      chamber: rep.chamber,
      party: rep.party,
      state: rep.state,
      district: rep.district,
      phone: rep.phone,
      office: rep.office,
      contact_form: rep.contact_form,
      twitter: rep.twitter_account,
      facebook: rep.facebook_account,
      youtube: rep.youtube_account,
      url: rep.url,
      next_election: rep.next_election
    };
  }

  async getRelevantCommittees(issueTag) {
    /**
     * Get congressional committees relevant to an issue
     */
    
    const committeeMap = {
      'foreign_affairs': ['HSFA', 'SSFR'], // House/Senate Foreign Affairs
      'humanitarian': ['HSFA', 'SSFR'],
      'refugees': ['HSFA', 'SSJU'], // Judiciary handles immigration
      'healthcare': ['HSIF', 'SSHR'], // Energy & Commerce, HELP
    };

    const committeeCodes = committeeMap[issueTag] || [];
    
    const committees = [];
    for (const code of committeeCodes) {
      try {
        const response = await axios.get(
          `${this.baseUrl}/117/house/committees/${code}.json`,
          {
            headers: { 'X-API-Key': this.apiKey }
          }
        );
        committees.push(response.data.results[0]);
      } catch (error) {
        // Try Senate if House fails
        try {
          const response = await axios.get(
            `${this.baseUrl}/117/senate/committees/${code}.json`,
            {
              headers: { 'X-API-Key': this.apiKey }
            }
          );
          committees.push(response.data.results[0]);
        } catch (err) {
          console.error('Committee fetch error:', err);
        }
      }
    }
    
    return committees;
  }
}

module.exports = CongressService;
```

#### Resistbot Integration (SMS-based advocacy)

```javascript
// services/resistbot_service.js

class ResistbotService {
  /**
   * Integrate with Resistbot for easy constituent messaging
   * Resistbot: Text "RESIST" to 50409
   */
  
  generateResistbotLink(campaign) {
    /**
     * Generate deep link to Resistbot with pre-filled message
     */
    
    const message = encodeURIComponent(campaign.message_template);
    const deepLink = `sms:50409&body=RESIST%20${message}`;
    
    return {
      sms_link: deepLink,
      phone_number: '50409',
      instructions: [
        'Text "RESIST" to 50409',
        'Follow the prompts to verify your address',
        'Send the message to your representatives'
      ],
      fallback_url: 'https://resist.bot'
    };
  }
}

module.exports = ResistbotService;
```

---

## 4. Action Matching & Relevance Scoring

```javascript
// services/action_matcher.js

class ActionMatcher {
  /**
   * Match actions to users based on location, preferences, and conflict relevance
   */
  
  constructor(db) {
    this.db = db;
  }

  async findRelevantActions(userId, conflictId, limit = 10) {
    /**
     * Find actions relevant to user and conflict
     */
    
    // Get user data
    const user = await this.db.query(
      'SELECT * FROM users WHERE id = $1',
      [userId]
    );
    
    const userLocation = {
      lat: user.rows[0].latitude,
      lon: user.rows[0].longitude
    };
    
    // Get conflict data
    const conflict = await this.db.query(
      'SELECT * FROM conflicts WHERE id = $1',
      [conflictId]
    );
    
    const conflictCountry = conflict.rows[0].country_code;
    const conflictTags = conflict.rows[0].tags || [];
    
    // Query actions with geospatial and relevance filtering
    const actions = await this.db.query(`
      SELECT 
        a.*,
        ST_Distance(
          ST_SetSRID(ST_MakePoint(a.longitude, a.latitude), 4326)::geography,
          ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography
        ) / 1000 as distance_km,
        (
          SELECT COUNT(*) 
          FROM unnest(a.tags) tag 
          WHERE tag = ANY($3)
        ) as tag_matches
      FROM actions a
      WHERE 
        a.type IN ('protest', 'petition', 'advocacy')
        AND a.start_time > NOW()
        AND (
          a.related_country = $4
          OR a.tags && $3
          OR ST_DWithin(
            ST_SetSRID(ST_MakePoint(a.longitude, a.latitude), 4326)::geography,
            ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography,
            50000  -- 50km radius
          )
        )
      ORDER BY 
        tag_matches DESC,
        distance_km ASC
      LIMIT $5
    `, [userLocation.lon, userLocation.lat, conflictTags, conflictCountry, limit]);
    
    // Calculate relevance scores
    const scoredActions = actions.rows.map(action => ({
      ...action,
      relevance_score: this.calculateRelevanceScore(action, user.rows[0], conflict.rows[0])
    }));
    
    // Sort by relevance
    scoredActions.sort((a, b) => b.relevance_score - a.relevance_score);
    
    return scoredActions;
  }

  calculateRelevanceScore(action, user, conflict) {
    /**
     * Calculate 0-1 relevance score for an action
     */
    
    let score = 0;
    
    // Geographic proximity (0-0.3)
    const distance = action.distance_km;
    if (distance <= 10) score += 0.3;
    else if (distance <= 50) score += 0.2;
    else if (distance <= 100) score += 0.1;
    
    // Tag matching (0-0.3)
    const tagMatch = action.tag_matches / Math.max(conflict.tags.length, 1);
    score += tagMatch * 0.3;
    
    // Country relevance (0-0.2)
    if (action.related_country === conflict.country_code) {
      score += 0.2;
    }
    
    // Action type preference (0-0.1)
    // Check user's past action participation
    score += 0.1; // Placeholder
    
    // Timing (0-0.1)
    const daysUntil = (new Date(action.start_time) - new Date()) / (1000 * 60 * 60 * 24);
    if (daysUntil <= 7) score += 0.1;
    else if (daysUntil <= 14) score += 0.05;
    
    return Math.min(1.0, score);
  }

  async getActionsByType(userId, actionType, limit = 20) {
    /**
     * Get actions filtered by type
     */
    
    const user = await this.db.query(
      'SELECT latitude, longitude FROM users WHERE id = $1',
      [userId]
    );
    
    const userLocation = user.rows[0];
    
    const actions = await this.db.query(`
      SELECT 
        a.*,
        ST_Distance(
          ST_SetSRID(ST_MakePoint(a.longitude, a.latitude), 4326)::geography,
          ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography
        ) / 1000 as distance_km
      FROM actions a
      WHERE 
        a.type = $3
        AND (
          a.start_time > NOW() OR a.type = 'petition'
        )
        AND ST_DWithin(
          ST_SetSRID(ST_MakePoint(a.longitude, a.latitude), 4326)::geography,
          ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography,
          100000  -- 100km for type-specific search
        )
      ORDER BY distance_km ASC
      LIMIT $4
    `, [userLocation.longitude, userLocation.latitude, actionType, limit]);
    
    return actions.rows;
  }
}

module.exports = ActionMatcher;
```

---

## 5. AI-Enhanced Action Descriptions

```javascript
// services/action_enhancer.js
const Anthropic = require('@anthropic-ai/sdk');

class ActionEnhancer {
  /**
   * Use Claude to generate engaging action descriptions
   */
  
  constructor(apiKey) {
    this.client = new Anthropic({ apiKey });
  }

  async enhanceProtestDescription(protest, conflictContext) {
    /**
     * Generate compelling protest description
     */
    
    const prompt = `Generate an engaging description for this protest/rally.

PROTEST DATA:
Title: ${protest.title}
Description: ${protest.description}
Location: ${protest.location.address}
Time: ${protest.start_time}
Organizer: ${protest.organizer?.name}

CONFLICT CONTEXT:
This protest is related to: ${conflictContext.country_name}
Key issues: ${conflictContext.key_needs?.map(n => n.need).join(', ')}

Generate JSON:
{
  "short_description": "One compelling sentence (30-40 words)",
  "why_attend": "3 reasons to join (bullet points)",
  "what_to_expect": "Brief overview of what will happen (50 words)",
  "how_it_helps": "Connection to the humanitarian cause (40 words)",
  "safety_tips": ["Safety tip 1", "Safety tip 2"],
  "what_to_bring": ["Suggested item 1", "Suggested item 2"],
  "accessibility": "Accessibility information",
  "call_to_action": "Motivating final message"
}

TONE: Motivating but realistic. Emphasize peaceful, constructive action.`
;

    const response = await this.client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1500,
      temperature: 0.4,
      messages: [{ role: 'user', content: prompt }]
    });

    return JSON.parse(response.content[0].text);
  }

  async enhancePetitionDescription(petition, conflictContext) {
    /**
     * Generate compelling petition description
     */
    
    const prompt = `Create compelling copy for this petition.

PETITION DATA:
Title: ${petition.title}
Description: ${petition.description}
Target: ${petition.target}
Current signatures: ${petition.signature_count}
Goal: ${petition.goal}

CONFLICT CONTEXT:
Related to: ${conflictContext.country_name}
Issue: ${conflictContext.summary}

Generate JSON:
{
  "short_description": "Hook sentence (20-30 words)",
  "why_sign": "Compelling reason to sign (75 words)",
  "impact": "What signing can achieve (50 words)",
  "urgency": "Why now matters (30 words)",
  "social_proof": "Message about current support",
  "call_to_action": "Final motivating message"
}

TONE: Urgent but hopeful. Focus on achievable goals.`;

    const response = await this.client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1200,
      temperature: 0.4,
      messages: [{ role: 'user', content: prompt }]
    });

    return JSON.parse(response.content[0].text);
  }

  async generateAdvocacyTemplate(campaign, representative, conflictContext) {
    /**
     * Generate template for contacting representatives
     */
    
    const prompt = `Create a template for contacting a government representative.

CAMPAIGN:
Issue: ${campaign.issue}
Ask: ${campaign.specific_ask}

REPRESENTATIVE:
Name: ${representative.name}
Chamber: ${representative.chamber}
State: ${representative.state}

CONFLICT CONTEXT:
Country: ${conflictContext.country_name}
Situation: ${conflictContext.summary}

Generate JSON:
{
  "subject_line": "Email subject",
  "greeting": "Appropriate greeting",
  "body_template": "Template with [personalization] placeholders",
  "key_points": ["Point 1", "Point 2", "Point 3"],
  "closing": "Closing paragraph",
  "signature_template": "How to sign",
  "customization_tips": ["Tip 1 for personalizing", "Tip 2"]
}

TONE: Respectful, clear, personal. Make it easy to customize.`;

    const response = await this.client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1500,
      temperature: 0.3,
      messages: [{ role: 'user', content: prompt }]
    });

    return JSON.parse(response.content[0].text);
  }
}

module.exports = ActionEnhancer;
```

---

## 6. Database Schema

```sql
-- Actions table (unified for all action types)
CREATE TABLE actions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    external_id VARCHAR(255), -- ID from source API
    source VARCHAR(50) NOT NULL, -- eventbrite, meetup, change_org, etc.
    type VARCHAR(50) NOT NULL, -- protest, petition, advocacy, community_gathering
    
    -- Basic info
    title VARCHAR(500) NOT NULL,
    description TEXT,