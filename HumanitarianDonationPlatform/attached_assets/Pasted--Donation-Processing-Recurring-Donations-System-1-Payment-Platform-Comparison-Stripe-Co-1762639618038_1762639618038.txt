# Donation Processing & Recurring Donations System

## 1. Payment Platform Comparison

### Stripe Connect (RECOMMENDED â­)

**Why Stripe Connect is Best for Your Use Case:**

```yaml
Pros:
  - Designed for marketplace/platform models
  - Direct payouts to nonprofits (verified accounts)
  - Built-in recurring billing (Stripe Subscriptions)
  - Excellent mobile SDKs (React Native)
  - PCI compliance handled automatically
  - Strong fraud prevention (Stripe Radar)
  - Supports 135+ currencies
  - Tax receipt generation
  - Detailed transaction reporting
  - Webhooks for real-time events
  - Application fees (you take 0-5% cut if needed)
  
Cons:
  - 2.9% + $0.30 per transaction (standard)
  - Requires nonprofit bank account verification
  - Learning curve for Connect setup

Pricing:
  - Standard: 2.9% + $0.30 per transaction
  - Your platform fee: 0-5% (optional)
  - No monthly fees
  - No setup fees
```

**Alternative: PayPal Giving Fund**
- Lower fees (1.99% + $0.49)
- But: Less control, slower payouts, limited customization

**Alternative: Donorbox**
- Built for nonprofits
- But: Higher fees (1.75% + Stripe), less flexibility

---

## 2. System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MOBILE APP (React Native)                 â”‚
â”‚              Stripe React Native SDK                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   YOUR BACKEND API                           â”‚
â”‚          (Node.js + Express or Python + FastAPI)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STRIPE CONNECT API                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Payment     â”‚  â”‚  Subscriptionsâ”‚  â”‚  Transfers   â”‚      â”‚
â”‚  â”‚  Intents     â”‚  â”‚  (Recurring)  â”‚  â”‚  (Payouts)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                ORGANIZATION STRIPE ACCOUNTS                  â”‚
â”‚          (Connected Accounts - Express or Standard)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ORGANIZATION BANK ACCOUNTS                      â”‚
â”‚            (Verified via Stripe Connect)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Technology Stack

### Core Technologies

```yaml
Backend:
  Framework: Node.js with Express.js (or Python FastAPI)
  Payment Processing: Stripe SDK (stripe npm package)
  Database: PostgreSQL (for transaction records)
  Cache: Redis (for idempotency, rate limiting)
  Queue: Bull (for async processing, retries)
  Encryption: bcrypt (for sensitive data), Stripe tokenization
  
Mobile SDK:
  React Native: @stripe/stripe-react-native
  Payment UI: Pre-built components
  Apple Pay: Built-in support
  Google Pay: Built-in support
  
Security:
  PCI Compliance: Handled by Stripe (no card data touches your servers)
  Encryption: TLS 1.2+ for all API calls
  Webhooks: HMAC signature verification
  Rate Limiting: express-rate-limit
  
Monitoring:
  Logging: Winston or Pino
  APM: Datadog or New Relic
  Error Tracking: Sentry
  
Testing:
  Unit Tests: Jest
  Integration Tests: Supertest
  Stripe Testing: Test mode with test cards
```

---

## 4. Stripe Connect Setup

### 4.1 Account Types

**For Your Platform (Main Account):**
```
Account Type: Standard Stripe Account
Purpose: Receive application fees, manage platform
```

**For Nonprofits (Connected Accounts):**
```
Account Type: Express Connected Accounts (RECOMMENDED)
Why: 
  - Faster onboarding (pre-built flow)
  - Stripe handles compliance/verification
  - Organizations don't need separate Stripe account
  
Alternative: Standard Connected Accounts
  - More control for organizations
  - Organizations manage their own Stripe dashboard
  - Longer onboarding
```

### 4.2 Implementation

```javascript
// config/stripe.js
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

module.exports = stripe;
```

```javascript
// services/stripe_connect_service.js
const stripe = require('../config/stripe');

class StripeConnectService {
  /**
   * Onboard a new nonprofit organization
   */
  
  async createConnectedAccount(organization) {
    /**
     * Create Express Connected Account for nonprofit
     */
    
    try {
      const account = await stripe.accounts.create({
        type: 'express',
        country: organization.country || 'US',
        email: organization.email,
        capabilities: {
          card_payments: { requested: true },
          transfers: { requested: true }
        },
        business_type: 'non_profit',
        business_profile: {
          name: organization.name,
          url: organization.website,
          mcc: '8398', // Charitable organizations MCC code
          product_description: organization.mission
        },
        metadata: {
          organization_id: organization.id,
          ein: organization.ein, // Tax ID
          verification_status: 'pending'
        }
      });

      // Store Stripe account ID
      await this.storeConnectedAccount(organization.id, account.id);

      return account;
    } catch (error) {
      console.error('Error creating connected account:', error);
      throw error;
    }
  }

  async createAccountLink(accountId, organizationId) {
    /**
     * Generate onboarding link for organization
     * They'll complete this to verify bank account, tax info, etc.
     */
    
    const accountLink = await stripe.accountLinks.create({
      account: accountId,
      refresh_url: `${process.env.APP_URL}/organizations/${organizationId}/onboarding/refresh`,
      return_url: `${process.env.APP_URL}/organizations/${organizationId}/onboarding/complete`,
      type: 'account_onboarding'
    });

    return accountLink.url;
  }

  async getAccountStatus(accountId) {
    /**
     * Check if account is fully onboarded and can receive payouts
     */
    
    const account = await stripe.accounts.retrieve(accountId);

    return {
      charges_enabled: account.charges_enabled,
      payouts_enabled: account.payouts_enabled,
      details_submitted: account.details_submitted,
      requirements: account.requirements
    };
  }

  async storeConnectedAccount(organizationId, stripeAccountId) {
    /**
     * Store Stripe account ID in your database
     */
    
    await db.query(`
      UPDATE organizations
      SET 
        stripe_account_id = $1,
        stripe_onboarding_completed = false,
        updated_at = NOW()
      WHERE id = $2
    `, [stripeAccountId, organizationId]);
  }
}

module.exports = StripeConnectService;
```

---

## 5. One-Time Donation Processing

### 5.1 Payment Flow

```
User selects amount â†’ App creates PaymentIntent â†’ User confirms â†’ Funds held â†’ Transfer to nonprofit â†’ Receipt sent
```

### 5.2 Backend Implementation

```javascript
// services/donation_service.js
const stripe = require('../config/stripe');
const { v4: uuidv4 } = require('uuid');

class DonationService {
  /**
   * Process one-time donation
   */
  
  async createDonation(donationData) {
    /**
     * donationData: {
     *   userId, organizationId, conflictId,
     *   amount, currency, paymentMethodId, 
     *   anonymous, dedicationMessage
     * }
     */
    
    const { 
      userId, 
      organizationId, 
      conflictId,
      amount, 
      currency = 'usd',
      paymentMethodId,
      anonymous = false,
      dedicationMessage 
    } = donationData;

    // Validate amount (minimum $5)
    if (amount < 5) {
      throw new Error('Minimum donation amount is $5');
    }

    // Get organization Stripe account
    const organization = await this.getOrganization(organizationId);
    
    if (!organization.stripe_account_id) {
      throw new Error('Organization is not set up to receive donations');
    }

    // Calculate fees
    const platformFee = this.calculatePlatformFee(amount); // 0-5%
    const applicationFeeAmount = Math.round(amount * platformFee * 100); // in cents

    // Generate idempotency key (prevent duplicate charges)
    const idempotencyKey = uuidv4();

    try {
      // Create PaymentIntent
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to cents
        currency: currency,
        payment_method: paymentMethodId,
        confirm: true, // Automatically confirm
        application_fee_amount: applicationFeeAmount,
        transfer_data: {
          destination: organization.stripe_account_id
        },
        metadata: {
          user_id: userId,
          organization_id: organizationId,
          conflict_id: conflictId || '',
          anonymous: anonymous.toString(),
          donation_type: 'one_time'
        },
        description: `Donation to ${organization.name}`,
        statement_descriptor: 'HUMANITARIAN AID',
        receipt_email: anonymous ? null : await this.getUserEmail(userId)
      }, {
        idempotencyKey: idempotencyKey
      });

      // Store donation record
      const donation = await this.storeDonation({
        id: uuidv4(),
        user_id: userId,
        organization_id: organizationId,
        conflict_id: conflictId,
        amount: amount,
        currency: currency,
        platform_fee: platformFee * amount,
        net_amount: amount - (platformFee * amount),
        stripe_payment_intent_id: paymentIntent.id,
        status: paymentIntent.status,
        anonymous: anonymous,
        dedication_message: dedicationMessage,
        payment_method_type: 'card'
      });

      // Send confirmation email (async)
      this.sendDonationConfirmation(donation);

      // Update user stats
      this.updateUserDonationStats(userId, amount);

      // Award badges if applicable
      this.checkAndAwardBadges(userId);

      return {
        success: true,
        donation_id: donation.id,
        amount: amount,
        organization: organization.name,
        payment_intent_id: paymentIntent.id
      };

    } catch (error) {
      console.error('Donation processing error:', error);
      
      // Store failed attempt
      await this.logFailedDonation({
        user_id: userId,
        organization_id: organizationId,
        amount: amount,
        error: error.message
      });

      throw error;
    }
  }

  calculatePlatformFee(amount) {
    /**
     * Calculate platform fee (can be 0% for full transparency)
     * Or use tiered structure
     */
    
    // Option 1: No platform fee (most transparent)
    return 0;

    // Option 2: Flat percentage
    // return 0.03; // 3%

    // Option 3: Tiered (larger donations = lower fee)
    // if (amount >= 1000) return 0.02;
    // if (amount >= 100) return 0.03;
    // return 0.05;
  }

  async getOrganization(organizationId) {
    const result = await db.query(
      'SELECT * FROM organizations WHERE id = $1',
      [organizationId]
    );
    
    if (!result.rows.length) {
      throw new Error('Organization not found');
    }
    
    return result.rows[0];
  }

  async getUserEmail(userId) {
    const result = await db.query(
      'SELECT email FROM users WHERE id = $1',
      [userId]
    );
    return result.rows[0]?.email;
  }

  async storeDonation(donationData) {
    const result = await db.query(`
      INSERT INTO donations (
        id, user_id, organization_id, conflict_id,
        amount, currency, platform_fee, net_amount,
        stripe_payment_intent_id, status, anonymous,
        dedication_message, payment_method_type,
        created_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW()
      ) RETURNING *
    `, [
      donationData.id,
      donationData.user_id,
      donationData.organization_id,
      donationData.conflict_id,
      donationData.amount,
      donationData.currency,
      donationData.platform_fee,
      donationData.net_amount,
      donationData.stripe_payment_intent_id,
      donationData.status,
      donationData.anonymous,
      donationData.dedication_message,
      donationData.payment_method_type
    ]);

    return result.rows[0];
  }

  async sendDonationConfirmation(donation) {
    /**
     * Send email receipt and in-app notification
     */
    
    // Queue email job
    await emailQueue.add('donation-receipt', {
      donation_id: donation.id,
      user_id: donation.user_id
    });

    // Send push notification
    await notificationService.send(donation.user_id, {
      title: 'Donation Confirmed! ğŸ’š',
      body: `Your $${donation.amount} donation has been processed`,
      data: { type: 'donation_success', donation_id: donation.id }
    });
  }

  async updateUserDonationStats(userId, amount) {
    await db.query(`
      UPDATE users
      SET 
        total_donated = total_donated + $2,
        donation_count = donation_count + 1,
        last_donation_at = NOW()
      WHERE id = $1
    `, [userId, amount]);
  }

  async checkAndAwardBadges(userId) {
    /**
     * Check if user earned any new badges
     */
    
    const user = await db.query(
      'SELECT total_donated, donation_count FROM users WHERE id = $1',
      [userId]
    );

    const { total_donated, donation_count } = user.rows[0];

    // First donation badge
    if (donation_count === 1) {
      await this.awardBadge(userId, 'first_donation');
    }

    // Milestone badges
    if (total_donated >= 1000) {
      await this.awardBadge(userId, 'philanthropist');
    } else if (total_donated >= 500) {
      await this.awardBadge(userId, 'generous_giver');
    } else if (total_donated >= 100) {
      await this.awardBadge(userId, 'supporter');
    }
  }

  async awardBadge(userId, badgeType) {
    await db.query(`
      INSERT INTO user_badges (user_id, badge_type, earned_at)
      VALUES ($1, $2, NOW())
      ON CONFLICT (user_id, badge_type) DO NOTHING
    `, [userId, badgeType]);
  }
}

module.exports = DonationService;
```

---

## 6. Recurring Donations (Subscriptions)

### 6.1 Subscription Flow

```
User sets up recurring â†’ Stripe creates Subscription â†’ Monthly charges â†’ Payouts to nonprofits â†’ Monthly reports
```

### 6.2 Implementation

```javascript
// services/subscription_service.js
const stripe = require('../config/stripe');

class SubscriptionService {
  /**
   * Create recurring donation subscription
   */
  
  async createRecurringDonation(subscriptionData) {
    /**
     * subscriptionData: {
     *   userId, amount, currency,
     *   paymentMethodId, frequency,
     *   allocation_type, organization_ids
     * }
     */
    
    const {
      userId,
      amount,
      currency = 'usd',
      paymentMethodId,
      frequency = 'monthly', // monthly, quarterly
      allocation_type, // fixed_org, algorithm_driven, user_selected
      organization_ids = []
    } = subscriptionData;

    // Validate
    if (amount < 10) {
      throw new Error('Minimum recurring donation is $10/month');
    }

    try {
      // Get or create Stripe customer
      const customerId = await this.getOrCreateCustomer(userId, paymentMethodId);

      // Create price object (for subscription)
      const price = await stripe.prices.create({
        unit_amount: Math.round(amount * 100),
        currency: currency,
        recurring: {
          interval: frequency === 'quarterly' ? 'month' : 'month',
          interval_count: frequency === 'quarterly' ? 3 : 1
        },
        product_data: {
          name: 'Monthly Humanitarian Donation',
          statement_descriptor: 'HUMANITY FUND'
        },
        metadata: {
          user_id: userId,
          allocation_type: allocation_type
        }
      });

      // Create subscription
      const subscription = await stripe.subscriptions.create({
        customer: customerId,
        items: [{ price: price.id }],
        default_payment_method: paymentMethodId,
        metadata: {
          user_id: userId,
          allocation_type: allocation_type,
          organization_ids: organization_ids.join(',')
        },
        // First charge happens immediately
        billing_cycle_anchor: 'now',
        // Email invoice to user
        collection_method: 'charge_automatically'
      });

      // Store subscription in database
      const recurringDonation = await this.storeRecurringDonation({
        id: uuidv4(),
        user_id: userId,
        stripe_subscription_id: subscription.id,
        stripe_price_id: price.id,
        amount: amount,
        currency: currency,
        frequency: frequency,
        allocation_type: allocation_type,
        organization_ids: organization_ids,
        status: 'active',
        next_charge_date: new Date(subscription.current_period_end * 1000)
      });

      // Send confirmation
      await this.sendSubscriptionConfirmation(recurringDonation);

      return {
        success: true,
        subscription_id: recurringDonation.id,
        stripe_subscription_id: subscription.id,
        amount: amount,
        frequency: frequency,
        next_charge: subscription.current_period_end
      };

    } catch (error) {
      console.error('Subscription creation error:', error);
      throw error;
    }
  }

  async getOrCreateCustomer(userId, paymentMethodId) {
    /**
     * Get existing Stripe customer or create new one
     */
    
    // Check if user already has Stripe customer ID
    const user = await db.query(
      'SELECT stripe_customer_id, email, full_name FROM users WHERE id = $1',
      [userId]
    );

    const userData = user.rows[0];

    if (userData.stripe_customer_id) {
      // Attach payment method to existing customer
      await stripe.paymentMethods.attach(paymentMethodId, {
        customer: userData.stripe_customer_id
      });

      return userData.stripe_customer_id;
    }

    // Create new customer
    const customer = await stripe.customers.create({
      email: userData.email,
      name: userData.full_name,
      payment_method: paymentMethodId,
      invoice_settings: {
        default_payment_method: paymentMethodId
      },
      metadata: {
        user_id: userId
      }
    });

    // Store customer ID
    await db.query(
      'UPDATE users SET stripe_customer_id = $1 WHERE id = $2',
      [customer.id, userId]
    );

    return customer.id;
  }

  async storeRecurringDonation(data) {
    const result = await db.query(`
      INSERT INTO recurring_donations (
        id, user_id, stripe_subscription_id, stripe_price_id,
        amount, currency, frequency, allocation_type, organization_ids,
        status, next_charge_date, created_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW()
      ) RETURNING *
    `, [
      data.id,
      data.user_id,
      data.stripe_subscription_id,
      data.stripe_price_id,
      data.amount,
      data.currency,
      data.frequency,
      data.allocation_type,
      data.organization_ids,
      data.status,
      data.next_charge_date
    ]);

    return result.rows[0];
  }

  async allocateFunds(subscriptionId, amount) {
    /**
     * When recurring charge succeeds, allocate funds to organizations
     */
    
    const subscription = await db.query(
      'SELECT * FROM recurring_donations WHERE stripe_subscription_id = $1',
      [subscriptionId]
    );

    const sub = subscription.rows[0];

    if (sub.allocation_type === 'fixed_org') {
      // Split evenly among selected organizations
      await this.splitAmongOrganizations(sub.organization_ids, amount, sub.user_id);
      
    } else if (sub.allocation_type === 'algorithm_driven') {
      // Use recommendation algorithm to select organizations
      const recommendedOrgs = await this.getRecommendedOrganizations(sub.user_id);
      await this.splitAmongOrganizations(recommendedOrgs, amount, sub.user_id);
      
    } else {
      // user_selected: user picks monthly
      // Store funds until user allocates
      await this.storePendingAllocation(sub.user_id, amount);
    }
  }

  async splitAmongOrganizations(organizationIds, amount, userId) {
    /**
     * Split donation amount among multiple organizations
     */
    
    const perOrgAmount = amount / organizationIds.length;

    for (const orgId of organizationIds) {
      await this.createDonation({
        userId: userId,
        organizationId: orgId,
        amount: perOrgAmount,
        source: 'recurring_subscription'
      });
    }
  }

  async cancelSubscription(userId, subscriptionId) {
    /**
     * Cancel recurring donation
     */
    
    const subscription = await db.query(
      'SELECT stripe_subscription_id FROM recurring_donations WHERE id = $1 AND user_id = $2',
      [subscriptionId, userId]
    );

    if (!subscription.rows.length) {
      throw new Error('Subscription not found');
    }

    const stripeSubId = subscription.rows[0].stripe_subscription_id;

    // Cancel in Stripe (at period end, so user gets full month)
    await stripe.subscriptions.update(stripeSubId, {
      cancel_at_period_end: true
    });

    // Update database
    await db.query(`
      UPDATE recurring_donations
      SET status = 'cancelling', updated_at = NOW()
      WHERE id = $1
    `, [subscriptionId]);

    return { success: true, message: 'Subscription will cancel at end of billing period' };
  }

  async updateSubscriptionAmount(userId, subscriptionId, newAmount) {
    /**
     * Update recurring donation amount
     */
    
    const subscription = await db.query(
      'SELECT stripe_subscription_id, stripe_price_id FROM recurring_donations WHERE id = $1 AND user_id = $2',
      [subscriptionId, userId]
    );

    if (!subscription.rows.length) {
      throw new Error('Subscription not found');
    }

    const { stripe_subscription_id, stripe_price_id } = subscription.rows[0];

    // Create new price
    const oldPrice = await stripe.prices.retrieve(stripe_price_id);
    
    const newPrice = await stripe.prices.create({
      unit_amount: Math.round(newAmount * 100),
      currency: oldPrice.currency,
      recurring: oldPrice.recurring,
      product: oldPrice.product
    });

    // Update subscription
    const stripeSubscription = await stripe.subscriptions.retrieve(stripe_subscription_id);
    
    await stripe.subscriptions.update(stripe_subscription_id, {
      items: [{
        id: stripeSubscription.items.data[0].id,
        price: newPrice.id
      }],
      proration_behavior: 'none' // Don't prorate, apply on next billing
    });

    // Update database
    await db.query(`
      UPDATE recurring_donations
      SET amount = $1, stripe_price_id = $2, updated_at = NOW()
      WHERE id = $3
    `, [newAmount, newPrice.id, subscriptionId]);

    return { success: true, new_amount: newAmount };
  }
}

module.exports = SubscriptionService;
```

---

## 7. Webhook Handling (Critical!)

### 7.1 Why Webhooks Matter

Stripe sends webhooks for events like:
- Payment succeeded
- Payment failed
- Subscription renewed
- Payout completed
- Refund processed

**You MUST handle these to keep your database in sync.**

### 7.2 Implementation

```javascript
// routes/webhooks.js
const express = require('express');
const router = express.Router();
const stripe = require('../config/stripe');

// IMPORTANT: Use raw body for webhook signature verification
router.post('/webhooks/stripe',
  express.raw({ type: 'application/json' }),
  async (req, res) => {
    const sig = req.headers['stripe-signature'];
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

    let event;

    try {
      // Verify webhook signature
      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
    } catch (err) {
      console.error('Webhook signature verification failed:', err.message);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    // Handle event
    try {
      await handleStripeWebhook(event);
      res.json({ received: true });
    } catch (error) {
      console.error('Webhook handler error:', error);
      res.status(500).json({ error: 'Webhook processing failed' });
    }
  }
);

async function handleStripeWebhook(event) {
  console.log(`Webhook received: ${event.type}`);

  switch (event.type) {
    case 'payment_intent.succeeded':
      await handlePaymentSuccess(event.data.object);
      break;

    case 'payment_intent.payment_failed':
      await handlePaymentFailure(event.data.object);
      break;

    case 'invoice.payment_succeeded':
      // Recurring donation charged successfully
      await handleSubscriptionPayment(event.data.object);
      break;

    case 'invoice.payment_failed':
      await handleSubscriptionPaymentFailure(event.data.object);
      break;

    case 'customer.subscription.deleted':
      await handleSubscriptionCancelled(event.data.object);
      break;

    case 'account.updated':
      // Connected account (nonprofit) status changed
      await handleAccountUpdate(event.data.object);
      break;

    case 'transfer.created':
      // Payout to nonprofit initiated
      await handleTransferCreated(event.data.object);
      break;

    case 'transfer.paid':
      // Payout to nonprofit completed
      await handleTransferPaid(event.data.object);
      break;

    default:
      console.log(`Unhandled event type: ${event.type}`);
  }
}

async function handlePaymentSuccess(paymentIntent) {
  // Update donation status
  await db.query(`
    UPDATE donations
    SET status = 'succeeded', updated_at = NOW()
    WHERE stripe_payment_intent_id = $1
  `, [paymentIntent.id]);

  console.log(`âœ“ Payment succeeded: ${paymentIntent.id}`);
}

async function handlePaymentFailure(paymentIntent) {
  await db.query(`
    UPDATE donations
    SET status = 'failed', error_message = $2, updated_at = NOW()
    WHERE stripe_payment_intent_id = $1
  `, [paymentIntent.id, paymentIntent.last_payment_error?.message]);

  // Notify user
  const donation = await db.query(
    'SELECT user_id FROM donations WHERE stripe_payment_intent_id = $1',
    [paymentIntent.id]
  );

  if (donation.rows.length) {
    await notificationService.send(donation.rows[0].user_id, {
      title: 'Payment Failed',
      body: 'Your donation could not be processed. Please update your payment method.',
      data: { type: 'payment_failed', payment_intent_id: paymentIntent.id }
    });
  }
}

async function handleSubscriptionPayment(invoice) {
  const subscriptionId = invoice.subscription;

  // Create donation record for this charge
  const subscription = await db.query(
    'SELECT * FROM recurring_donations WHERE stripe_subscription_id = $1',
    [subscriptionId]
  );

  if (subscription.rows.length) {
    const sub = subscription.rows[0];

    // Allocate funds
    await subscriptionService.allocateFunds(
      subscriptionId,
      invoice.amount_paid / 100 // Convert from cents
    );

    // Update next charge date
    await db.query(`
      UPDATE recurring_donations
      SET 
        next_charge_date = to_timestamp($2),
        last_charge_date = NOW(),
        total_charged = total_charged + $3
      WHERE stripe_subscription_id = $1
    `, [subscriptionId, invoice.period_end, invoice.amount_paid / 100]);

    console.log(`âœ“ Subscription payment processed: ${subscriptionId}`);
  }
}

async function handleSubscriptionPaymentFailure(invoice) {
  const subscriptionId = invoice.subscription;

  await db.query(`
    UPDATE recurring_donations
    SET status = 'payment_failed', updated_at = NOW()
    WHERE stripe_subscription_id = $1
  `, [subscriptionId]);

  // Notify user
  const subscription = await db.query(
    'SELECT user_id FROM recurring_donations WHERE stripe_subscription_id = $1',
    [subscriptionId]
  );

  if (subscription.rows.length) {
    await notificationService.send(subscription.rows[0].user_id, {
      title: 'Recurring Donation Failed',
      body